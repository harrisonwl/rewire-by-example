<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="chapters/cover/rewire-by-example.html">ReWire by Example</a></li><li class="chapter-item expanded "><a href="chapters/chapter0/prequisites.html"><strong aria-hidden="true">1.</strong> Prerequisites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/chapter0/haskell.html"><strong aria-hidden="true">1.1.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="chapters/chapter0/monadwrangling/monadwrangling.html"><strong aria-hidden="true">1.2.</strong> Monads in Haskell</a></li></ol></li><li class="chapter-item expanded "><a href="chapters/chapter1/helloworlds.html"><strong aria-hidden="true">2.</strong> Chapter 1: Hello Worlds in ReWire</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/chapter1/simplemealy.html"><strong aria-hidden="true">2.1.</strong> Simple Mealy</a></li><li class="chapter-item expanded "><a href="chapters/chapter1/fibonacci.html"><strong aria-hidden="true">2.2.</strong> Fibonacci, of course</a></li><li class="chapter-item expanded "><a href="chapters/chapter1/carrysaveadders.html"><strong aria-hidden="true">2.3.</strong> Carry Save Adders</a></li></ol></li><li class="chapter-item expanded "><a href="chapters/chapter2/simpleprocs.html"><strong aria-hidden="true">3.</strong> Chapter 2: Simple Processors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapters/chapter2/tinyisa.html"><strong aria-hidden="true">3.1.</strong> Tiny ISA</a></li></ol></li><li class="chapter-item expanded "><a href="crossbarswitch.html"><strong aria-hidden="true">4.</strong> Cross Bar Switch</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rewire-by-example"><a class="header" href="#rewire-by-example">ReWire by Example</a></h1>
<p>The ReWire functional high-level synthesis language (see below) is a functional language for designing, verifying, and implementing high assurance hardware. A hardware design in ReWire is also a Haskell program, and development of ReWire designs benefits from immediate feedback from its strong, static type system. As with Rust, ReWire's type system enforces invariants and guarantees at compile-time, thereby eliminating whole classes of bugs statically in a lightweight, automated manner. ReWire's type system can be extended by embedding designs into assurance tools (like Coq) to capture broad of automated checks and proof tools. ReWire designs can be compiled into Verilog and thereby interoperate with synthesis tools. ReWire is not a replacement for commodity hardware design languages like Verilog but rather it is a value-add for hardware design, implementation, and verification that interoperates with them.</p>
<p align="center"><img src="chapters/cover/images/ReWireUses.png"  style="height:50%; width:50%" ></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-0-before-you-start"><a class="header" href="#chapter-0-before-you-start">Chapter 0: Before You Start</a></h1>
<p>These are the tutorial notes for the ReWire language.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="haskell"><a class="header" href="#haskell">Haskell</a></h3>
<p>There's no way of learning ReWire without knowing basic Haskell. I'm a Mac guy so I would use <code>homebrew</code> as in</p>
<ul>
<li><code>brew install ghc</code>. This will install the Glasgow Haskell Compiler.</li>
<li><code>brew install stack</code>. Stack is a tool for installing haskell packages. It really makes things easy (well, easier).</li>
</ul>
<h3 id="installing-rewire"><a class="header" href="#installing-rewire">Installing ReWire</a></h3>
<p>ReWire is freely available. Here is the repository where you find the most recent version: <a href="https://github.com/twosixlabs/ReWire">ReWire source</a>. Follow the directions -- <code>stack</code> makes it easy.</p>
<ul>
<li>This installation will build the ReWire compiler <code>rwc</code> and</li>
<li>Install libraries (aka <code>ReWire-user</code>) that allow you to program in ReWire with the Haskell interpreter <code>ghci</code>.</li>
</ul>
<h3 id="monads-in-haskell"><a class="header" href="#monads-in-haskell">Monads in Haskell</a></h3>
<p>You have to be comfortable with the basics of "monad wrangling". You don't need to understand them in any great depth, but understanding the following ought to do:</p>
<ol>
<li>The <code>Identity</code> monad;</li>
<li>the state monad; and</li>
<li>the <code>Maybe</code> monad.</li>
</ol>
<p>Understanding the basic usage of the <code>StateT</code> monad transformer is important. It's a shame that they are known as "transformer" instead of "constructor", because all a monad transformer is is a way to construct monads in a canonical fashion.</p>
<p>Monads are a concept from Category Theory. I love Category Theory, really I do. But I'd <strong>strongly</strong> recommend avoiding categorical treatments of monads if this is your first time with this material. Rather, check out Graham Hutton or Miran Lipovaca's texts as they're both excellent.</p>
<h4 id="reactive-resumption-monads"><a class="header" href="#reactive-resumption-monads">Reactive Resumption Monads</a></h4>
<p>These are a particular family of monads that can be used to precisely describe synchronous concurrency (e.g., like clocked computations in hardware). They sound scary, but they're not. Check out the following papers of mine for the basics if you want. I suspect a lot of readers will just look at its usage in ReWire and get them well enough.</p>
<ol>
<li><a href="https://bibbase.org/network/publication/harrison-theessenceofmultitasking-2006">Essence of Multitasking</a> and</li>
<li><a href="https://bibbase.org/network/publication/harrison-procter-cheapbutfunctionalthreads-2015">Cheap (But Functional) Threads</a>.</li>
</ol>
<p>These monads are implemented in the Hackage package <a href="https://hackage.haskell.org/package/monad-resumption">monad-resumption</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="haskell-1"><a class="header" href="#haskell-1">Haskell</a></h2>
<p>Here are some good sources:</p>
<ul>
<li><strong>Programming in Haskell</strong> by Graham Hutton.
This is an excellent, step-by-step introduction to Haskell. Graham also has a lot of online resources (slides, videos, etc.) to go along with the book.</li>
<li><strong>Learn You a Haskell for Good</strong> by Miran Lipovaca.
Highly amusing and informative; available <a href="https://learnyouahaskell.com/">here</a>.</li>
<li><strong>A Gentle Introduction to Haskell</strong> by Hudak, Peterson, and Fasal.
Available at <a href="http://www.haskell.org/tutorial/">http://www.haskell.org/tutorial/</a>.</li>
<li><strong>Real World Haskell</strong> by Bryan O'Sullivan.
Also available online (I believe).</li>
<li>Google.</li>
<li><strong>Haskell for Grownups</strong>. These are some slides (<a href="chapters/chapter0/HaskellForGrownups.pdf">HaskellForGrownups.pdf</a>) I've presented here and there over the years as a quick intro to Haskell and what all the fuss is about.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monad-wrangling-101"><a class="header" href="#monad-wrangling-101">Monad Wrangling 101</a></h1>
<p>ReWire is a monadic language, meaning that it is organized in terms of various monads (which ones, we'll get to shortly). There are about a zillion tutorials on monads out there, and most of them are just <em>terrible</em>. This is a shame since the idea of a monad itself is really beautiful and, if you know how to use them correctly, they're a really important part of functional programming practice. And, furthermore, they are a really important part of programming language semantics, too, and consequently an important part of formal methods properly understood.</p>
<p>What this section does is introduce the monad idea through a sequence of simple language interpreters. As we add features to the language, we have to change the monad we use to define the new interpreter. We will see four interpreters whose core is a language of simple arithmetic expressions.</p>
<p>To see all of the monads discussed in this tutorial defined in one convenient Haskell file, download this:
<a href="chapters/chapter0/monadwrangling/MonadWrangling.hs">MonadWrangling.hs</a>. These monad and monad transformer definitions are in the style of earlier versions of GHC, which were immensely easier to understand than the current mess.</p>
<hr />
<h2 id="simple-arithmetic-expressions"><a class="header" href="#simple-arithmetic-expressions">Simple Arithmetic Expressions</a></h2>
<p>The first interpreter, found in <a href="chapters/chapter0/monadwrangling/Arith.hs">Arith.hs</a>, defines a language <code>Exp</code> that has integer constants, negation, and addition. These correspond to the constructors <code>Const</code>, <code>Neg</code>, and <code>Add</code> of the <code>Exp</code> data type. The interpreter <code>eval0</code> does not use a monad and should be fairly self-explanatory.</p>
<pre><code class="language-haskell">module Arith where

data Exp = Const Int | Neg Exp | Add Exp Exp

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2

eval0 :: Exp -&gt; Int
eval0 (Const i)   = i
eval0 (Neg e)     = - (eval0 e)
eval0 (Add e1 e2) = eval0 e1 + eval0 e2

c = Const 99
n = Neg c
a = Add c n
</code></pre>
<p>Loading this into GHCi gives you what you'd expect:</p>
<pre><code>λ&gt; a
99 + -99
λ&gt; eval0 a
0
</code></pre>
<hr />
<h2 id="the-identity-monad-is-a-big-nothingburger"><a class="header" href="#the-identity-monad-is-a-big-nothingburger">The <code>Identity</code> Monad is a Big Nothingburger</a></h2>
<p>We introduce now the <code>Identity</code> monad, which doesn't really give you anything at all. I introduce it first because it uses Haskell's built-in monad syntax, and it's useful to meet that syntax first when the monad is just a big nothing. The code for this section is found in <a href="chapters/chapter0/monadwrangling/IdentityMonad.hs">IdentityMonad.hs</a> and <a href="chapters/chapter0/monadwrangling/IdentityMonadDo.hs">IdentityMonadDo.hs</a>.</p>
<p>First, here's the new interpreter <code>eval1</code>. The salient point is that <code>eval0</code> and <code>eval1</code> are doing the same thing, but what's all this <code>return</code> and <code>&gt;&gt;=</code> business? (They're explained below if you want to skip ahead.)</p>
<pre><code class="language-haskell">module IdentityMonad where

import Control.Monad.Identity -- this is new.

data Exp = Const Int | Neg Exp | Add Exp Exp

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2

eval1 :: Exp -&gt; Identity Int
eval1 (Const i)   = return i
eval1 (Neg e)     = eval1 e &gt;&gt;= \ v -&gt; return (- v)
eval1 (Add e1 e2) = eval1 e1 &gt;&gt;= \ v1 -&gt; eval1 e2 &gt;&gt;= \ v2 -&gt; return (v1 + v2)

c = Const 99
n = Neg c
a = Add c n
</code></pre>
<p>The <code>Identity</code> monad has the following definition (it's actually a simplification).</p>
<pre><code class="language-haskell">data Identity a = Identity a -- apologies for overloading the constructors.
return :: a -&gt; Identity a
return v = Identity v
(&gt;&gt;=) :: Identity a -&gt; (a -&gt; Identity b) -&gt; Identity b
(Identity v) &gt;&gt;= f = f v
</code></pre>
<p>So, <code>return</code> just injects its argument into <code>Identity</code>. The operation <code>&gt;&gt;=</code> (a.k.a., "bind") boils down to a backwards apply. It's just a whole lot of applying and pattern-matching on the <code>Identity</code> constructor, signifying nothing. When you load all this into GHCi, you get just what you'd expect:</p>
<pre><code>λ&gt; a
99 + -99
λ&gt; eval1 a
Identity 0
λ&gt; 
</code></pre>
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<p>As people say, <code>eval1</code> and <code>eval0</code> are morally equivalent, in the sense that, if you were so inclined, you could <em>prove</em> the equality <code>eval1 a = Identity (eval0 a)</code> holds for any <code>a</code>.</p>
<h3 id="monadic-syntactic-sugar-or-saccharine"><a class="header" href="#monadic-syntactic-sugar-or-saccharine">Monadic Syntactic Sugar or Saccharine?</a></h3>
<p>Haskell overloads its monad syntax, so when we see the <code>&gt;&gt;=</code> and <code>return</code> again, they will be typed in different monads than <code>Identity</code>. Overloading is great for some uses, because it removes clutter. I find for formal methods it can be kind of confusing. So, reader beware!</p>
<p>There is also another shorthand for <code>&gt;&gt;=</code> that is frequently used called <code>do</code> notation; it's defined as:</p>
<pre><code class="language-haskell">   x &gt;&gt;= f = do
               v &lt;- x
		       f v
</code></pre>
<p>So, the clause of <code>eval1</code> for <code>Neg</code> is as follows when written in <code>do</code> notation:</p>
<pre><code class="language-haskell">eval1 (Neg e)     = do
                      v &lt;- eval1 e
                      return (- v)
</code></pre>
<p>The code <code>IdentityMonadDo.hs</code> just reformulates the code in <code>IdentityMonad.hs</code> using <code>do</code> notation.</p>
<hr />
<h2 id="2nd-interpreter-errors-and-maybe"><a class="header" href="#2nd-interpreter-errors-and-maybe">2nd Interpreter: Errors and Maybe</a></h2>
<p>The code for this section is found in <a href="chapters/chapter0/monadwrangling/Errors.hs">Errors.hs</a>. This new interpreter adds a new arithmetic operation <code>Div</code>. I pasted in the <code>eval0</code> with a new case for <code>Div</code>.</p>
<pre><code class="language-haskell">module Errors where

data Exp = Const Int | Neg Exp | Add Exp Exp
         | Div Exp Exp                      -- new

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2
  show (Div e1 e2) = show e1 ++ " / " ++ show e2

-- | Same as before, but with a new case
eval0 :: Exp -&gt; Int
eval0 (Const i)   = i
eval0 (Neg e)     = - (eval0 e)
eval0 (Add e1 e2) = eval0 e1 + eval0 e2
eval0 (Div e1 e2) = eval0 e1 `div` eval0 e2 -- new

a    = Add c (Neg c)
        where
          c = Const 99
uhoh = Div (Const 1) (Const 0)              -- new
</code></pre>
<p>Note that, when you run the <code>Div</code>-extended version of <code>eval0</code>, things don't always end well:</p>
<pre><code class="language-haskell">λ&gt; uhoh
1 / 0
λ&gt; eval0 uhoh
*** Exception: divide by zero
λ&gt; 
</code></pre>
<h3 id="why-cant-we-just-check-for-0"><a class="header" href="#why-cant-we-just-check-for-0">Why can't we just check for 0?</a></h3>
<p>Think about it this way, what should I replace <code>????</code> with below? There's no way of handling that exceptional case and it crashes the program.</p>
<pre><code class="language-haskell">eval0 (Div e1 e2) = if v2 == 0 then ???? else eval0 e1 `div` v2 
   where
      v2 = eval0 e2
</code></pre>
<p>But with the <code>Maybe</code> monad, we can use its <code>Nothing</code> constructor for this erroneous case; recall the definition of the <code>Maybe</code> data type:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>Here's the definition of <code>eval2</code> whhich is typed in the <code>Maybe</code> monad:</p>
<pre><code class="language-haskell">eval2 :: Exp -&gt; Maybe Int     -- N.b., the new type
eval2 (Const i)   = return i
eval2 (Neg e)     = do
                      v &lt;- eval2 e
                      return (- v)
eval2 (Add e1 e2) = do
                      v1 &lt;- eval2 e1
                      v2 &lt;- eval2 e2
                      return (v1 + v2)
eval2 (Div e1 e2) = do
                      v1 &lt;- eval2 e1
                      v2 &lt;- eval2 e2
                      if v2==0 then Nothing else return (v1 `div` v2) -- fill in ???? with Nothing
</code></pre>
<pre><code class="language-haskell">λ&gt; uhoh
1 / 0
λ&gt; eval2 uhoh
Nothing
</code></pre>
<h3 id="maybe-under-the-hood"><a class="header" href="#maybe-under-the-hood">Maybe Under the Hood</a></h3>
<p>Below is the definition of the <code>Maybe</code> monad. The way to think of a computation <code>x &gt;&gt;= f</code> is that, if <code>x</code> is returns some value (i.e., it's <code>Just v</code>), then just proceed normally. If an exception is thrown by computing <code>x</code> (i.e., it's <code>Nothing</code>), then the whole computation <code>x &gt;&gt;= f</code></p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a

return :: a -&gt; Maybe a
return v = Just v

(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b 
(Just v) &gt;&gt;= f = f v
Nothing &gt;&gt;= f  = Nothing
</code></pre>
<hr />
<h1 id="3rd-interpreter-adding-a-register"><a class="header" href="#3rd-interpreter-adding-a-register">3rd Interpreter: Adding a Register</a></h1>
<p>The code for this section is <a href="chapters/chapter0/monadwrangling/Register.hs">Register.hs</a>.</p>
<pre><code class="language-haskell">module Register where

import Control.Monad.State

data Exp = Const Int | Neg Exp | Add Exp Exp
         | X  -- new register X

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2
  show X           = "X"

-- | Just a copy 
eval2 :: Exp -&gt; Maybe Int
eval2 (Const i)   = return i
eval2 (Neg e)     = do
                      v &lt;- eval2 e
                      return (- v)
eval2 (Add e1 e2) = do
                      v1 &lt;- eval2 e1
                      v2 &lt;- eval2 e2
                      return (v1 + v2)

eval2 X           = undefined -- How do we do handle this?
</code></pre>
<p>Here's how we handle this:</p>
<ul>
<li>Create a new monad from <code>Identity</code> with an <code>Int</code> register: <code>StateT Int Identity</code></li>
<li>This new monad has two operations
<ul>
<li><code>get</code> that reads the current value of the register</li>
<li><code>put</code> that updates the value of the register</li>
</ul>
</li>
<li><code>StateT Int</code> is known as a <em>monad transformer</em></li>
</ul>
<p>The code below does just that</p>
<pre><code class="language-haskell">readX :: StateT Int Identity Int
readX = get

eval3 :: Exp -&gt; StateT Int Identity Int
eval3 (Const i)   = return i
eval3 (Neg e)     = do
                      v &lt;- eval3 e
                      return (- v)
eval3 (Add e1 e2) = do
                      v1 &lt;- eval3 e1
                      v2 &lt;- eval3 e2
                      return (v1 + v2)

eval3 X           = readX
</code></pre>
<hr />
<h1 id="4th-errors--register"><a class="header" href="#4th-errors--register">4th: Errors + Register</a></h1>
<p>The code for this is <a href="chapters/chapter0/monadwrangling/RegisterError.hs">RegisterError.hs</a>. In this example, we want to add both a possibly error-producing computation along with the register. This is done mostly through monadic means.</p>
<pre><code class="language-haskell">module Register where

import Control.Monad.State

data Exp = Const Int | Neg Exp | Add Exp Exp
         | Div Exp Exp  -- Both errors
         | X            -- and a register X

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2
  show (Div e1 e2) = show e1 ++ " / " ++ show e2
  show X           = "X"
</code></pre>
<p>Here's how we handle this:</p>
<ul>
<li>Create a new monad from <code>Maybe</code> with an <code>Int</code> register: <code>StateT Int Maybe</code></li>
<li>This new monad has two operations
<ul>
<li><code>get</code> that reads the current value of the register</li>
<li><code>put</code> that updates the value of the register</li>
</ul>
</li>
<li><code>StateT Int</code> is known as a <em>monad transformer</em></li>
</ul>
<p>The code below does just that</p>
<pre><code class="language-haskell">readX :: StateT Int Maybe Int
readX = get

eval3 :: Exp -&gt; StateT Int Maybe Int
eval3 (Const i)   = return i
eval3 (Neg e)     = do
                      v &lt;- eval3 e
                      return (- v)
eval3 (Add e1 e2) = do
                      v1 &lt;- eval3 e1
                      v2 &lt;- eval3 e2
                      return (v1 + v2)
eval3 (Div e1 e2) = do
                      v1 &lt;- eval3 e1
                      v2 &lt;- eval3 e2
                      if v2==0 then lift Nothing else return (v1 `div` v2)
                                 -- N.b., this is new.

eval3 X           = readX
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-worlds"><a class="header" href="#hello-worlds">Hello Worlds</a></h1>
<p>This first chapter introduces ReWire and collects the simplest possible examples.</p>
<h2 id="what-is-rewire"><a class="header" href="#what-is-rewire">What is ReWire?</a></h2>
<p>ReWire is a domain-specific language embedded in the Haskell functional programming language (<a href="https://haskell.org">https://haskell.org</a>). <em>Every</em> ReWire program is a Haskell program that can be executed just as any other Haskell program. This fact is simple and also very powerful, because it means that development of a hardware design can proceed <em>incrementally</em>, one function at a time, with the resulting new code being type-checked and/or tested. Once a developer is satisfied with their ReWire design, they can compile it automatically into synthesizable HDLs (hardware definition languages) like Verilog, VHDL, and FIRRTL.</p>
<img src="chapters/chapter1/images/ReWireInColor.png"  style="height:60%; width:60%" >
<h3 id="mealy-machines-and-rewire-types"><a class="header" href="#mealy-machines-and-rewire-types">Mealy Machines and ReWire types</a></h3>
<p>There's a mental model of digital circuitry used by hardware designers known as a Mealy machine. The flavor favored by hardware designers is portrayed below, which will seem odd to those of us who first heard of them from a class in theoretical computer science (e.g., <a href="https://en.wikipedia.org/wiki/Mealy_machine">https://en.wikipedia.org/wiki/Mealy_machine</a>). Mealy machines are finite state machines combined with a clock that on each clock "tick" consume an input of type <code>i</code>, update a store of type <code>s</code>, and produce an output of type <code>o</code>.</p>
<img src="chapters/chapter1/images/beautifullestmealy.png"  style="height:50%; width:50%" >
<p>In ReWire, there is a type corresponding to the Mealy machine above, the monadic type:</p>
<p><code>ReacT i o (StateT s Identity) ()</code></p>
<p>And, because it occurs so frequently, we refer to it as a <em>device type</em> some times. Things of this type are those that can be compiled to hardware.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simple-mealy"><a class="header" href="#simple-mealy">Simple Mealy</a></h2>
<p>The "theoretical computer science" picture of a Mealy machine is seen below:</p>
<img src="chapters/chapter1/images/Mealy.png"  style="height:17%; width:17%" >
<p>Here <code>si</code> is the start state, and there are two other states, <code>s0</code> and <code>s1</code>. There is also an alphabet consisting of <code>0</code> and <code>1</code>. On the transitions, a red digit denotes an input and a blue digit denotes an output, so, in the machine is currently in state <code>si</code> and receives a <code>1</code> as input, it outputs a <code>0</code> and proceeds to state <code>s1</code>.</p>
<p>The ReWire code described in the section is found here, <a href="chapters/chapter1/SimpleMealy.hs">SimpleMealy.hs</a>, and what follows is a line-by-line description.</p>
<p>First thing is to import a library with ReWire definitions, etc. What's <code>DataKinds</code>? Don't worry about it for now. Collected in a comment is a tabular form of the state transitions.</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
import ReWire

-- Current State | Input | Output | Next State
-- --------------------------------------------
--    si             0       0          s0
--    si             1       0          s1
--    s0             0       0          s0
--    s0             1       1          s1
--    s1             0       1          s0
--    s1             1       0          s1
</code></pre>
<p>Next, let's define the alphabet:</p>
<pre><code class="language-haskell">data Alphabet = Zero | One
</code></pre>
<p><code>Alphabet</code> defines both the inputs and outputs of this Mealy machine.</p>
<p>Each of the three states and their transitions are defined in the following. Before focusing on the type, note first how each line below corresponds directly to a line in the table above. E.g., if the machine is in state <code>si</code> and receives <code>0</code> as input, it produces output <code>0</code>, and proceeds to state <code>s0</code>.</p>
<pre><code class="language-haskell">si , s0 , s1 :: Alphabet -&gt; ReacT Alphabet Alphabet Identity ()

si Zero = signal Zero &gt;&gt;= s0
si One  = signal Zero &gt;&gt;= s1

s0 Zero = signal Zero &gt;&gt;= s0
s0 One  = signal One  &gt;&gt;= s1

s1 Zero = signal One  &gt;&gt;= s0
s1 One  = signal Zero &gt;&gt;= s1
</code></pre>
<p>We'll return to the types of <code>si</code>, <code>s0</code>, and <code>s1</code> momentarily.</p>
<p>Finally, we need to designate a start state, just as with any state machine definition.</p>
<pre><code class="language-haskell">start :: ReacT Alphabet Alphabet Identity ()
start = signal Zero &gt;&gt;= si
</code></pre>
<h4 id="why-this-type-react-alphabet-alphabet-identity-"><a class="header" href="#why-this-type-react-alphabet-alphabet-identity-">Why this type <code>ReacT Alphabet Alphabet Identity ()</code>?</a></h4>
<p>We know the type will have the form <code>ReacT i o m a</code> for some types <code>i</code>, <code>o</code>, and <code>a</code> and monad <code>m</code>.</p>
<ul>
<li>The input alphabet is <code>Alphabet</code>, so <code>i</code> is <code>Alphabet</code>.</li>
<li>The output alphabet is <code>Alphabet</code>, so <code>o</code> is also <code>Alphabet</code>.</li>
<li>We are not using internal storage like registers, so monad <code>m</code> can be just <code>Identity</code>.</li>
</ul>
<p>Finally, why <code>()</code> for return type <code>a</code>? Here, we have a choice, but it doesn't matter in the least what we pick. Because <code>start</code> never, ever, terminates under any circumstances, it won't ever return any value, so we may as well pick <code>()</code>.</p>
<p>This non-termination requirement on <code>start</code> is important and makes complete sense if you think about it. Hardware <strong>never</strong> terminates (unless it's unplugged).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-obligatory-fibonacci-example"><a class="header" href="#the-obligatory-fibonacci-example">The Obligatory Fibonacci Example</a></h2>
<p>The following Haskell code (the file is called <a href="chapters/chapter1/Fib.hs">Fib.hs</a>) creates an infinite list of <code>Int</code>s in a conventional manner using the <code>fibgen</code> function.</p>
<pre><code class="language-haskell">module Fibonacci where

fibs :: [Int]
fibs = fibgen 0 1
  where
    fibgen :: Int -&gt; Int -&gt; [Int]
    fibgen n m = n : fibgen m (n + m)
</code></pre>
<p>Loading <code>Fib.hs</code> into GHCi, you can see that it calculates the familiar Fibonacci sequence:</p>
<pre><code class="language-haskell">ghci&gt; take 10 fibs
take 10 fibs
[0,1,1,2,3,5,8,13,21,34]
</code></pre>
<h3 id="making-hardware-out-of-this"><a class="header" href="#making-hardware-out-of-this">Making Hardware Out of This.</a></h3>
<p>In the ReWire code below, <code>fibdev</code> plays the same role as <code>fibgen</code> above. For the moment, just ignore the monadic type, <code>ReacT Bit (W 8) Identity ()</code>. (I'll explain its significance shortly.) Instead of using Haskell's <code>Int</code> type, we will compute over eight bit words (i.e., <code>W 8</code>). There is also a definition of <code>start</code>, which is a special symbol that unsurprisingly specifies how to start the device.</p>
<p>What <code>fibdev</code> does is, given two words <code>n</code> and <code>m</code>, it puts <code>n</code> on the output port using <code>signal</code> and accepts a new input <code>b</code> off of the input port. If bit <code>b</code> is <code>1</code>, then it continues on. However, if <code>b</code> is <code>0</code>, then it calls itself on <code>m</code> and <code>m + n</code> just like <code>fibgen</code> above.</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
import Prelude hiding ((+))
import ReWire
import ReWire.Bits

start :: ReacT Bit (W 8) Identity ()
start = fibdev (lit 0) (lit 1)

fibdev :: W 8 -&gt; W 8 -&gt; ReacT Bit (W 8) Identity ()
fibdev n m = do b &lt;- signal n
                if b then fibdev n m else fibdev m (n + m)
</code></pre>
<h3 id="lessons-learned-1"><a class="header" href="#lessons-learned-1">Lessons Learned.</a></h3>
<p>There are some lessons to be learned from this example.</p>
<ul>
<li>Just like a state machine, every ReWire device has to have a <code>start</code>.</li>
<li>Most ReWire programs will begin with something like the top three lines of the previous ReWire code.
<ul>
<li>There may be Haskell <code>Prelude</code> operations that have a particular meaning in ReWire (e.g., <code>+</code>), and so they may need to be hidden explicitly.</li>
<li>The other parts of that incantation is performed to use built-in words and their operations.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="carry-save-addition"><a class="header" href="#carry-save-addition">Carry Save Addition</a></h2>
<p>There are three carry-save adders in the tutorial, <a href="chapters/chapter1/CSA.hs">CSA.hs</a>, <a href="chapters/chapter1/SCSA.hs">SCSA.hs</a>, and <a href="chapters/chapter1/PCSA.hs">PCSA.hs</a>, and the first of these is explained in detail below.</p>
<p>Carry save addition (<a href="https://en.wikipedia.org/wiki/Carry-save_adder">https://en.wikipedia.org/wiki/Carry-save_adder</a>) is defined as function <code>f</code>:</p>
<pre><code class="language-haskell">f :: W 8 -&gt; W 8 -&gt; W 8 -&gt; (W 8, W 8)
f a b c = ( ((a .&amp;. b) .|. (a .&amp;. c) .|. (b .&amp;. c) ) &lt;&lt;. lit 1 , (a ^ b) ^ c )
</code></pre>
<p>Here, I define <code>f</code> using ReWire's built-in word constructor, picking <code>W 8</code> for the sake of concreteness.
I'll define a few constants for convenience in a running example.</p>
<pre><code class="language-haskell">_40 , _25 , _20 , _41 , _0 :: W 8
_40 = lit 40
_25 = lit 25
_20 = lit 20
_41 = lit 41
_0  = lit 0
</code></pre>
<p>Using GHCi, we can test it out, like any Haskell function:</p>
<pre><code class="language-haskell">λ&gt; :t f
f :: W 8 -&gt; W 8 -&gt; W 8 -&gt; (W 8, W 8)
λ&gt; f _40 _25 _20
(Vector [False,False,True,True,False,False,False,False],Vector [False,False,True,False,False,True,False,True])
</code></pre>
<p>What's this mess? <code>W 8</code> values are represented internally using Haskell's <code>Data.Vector</code> library and, well, it ain't pretty. There is a ReWire library you can import to make all this more palatable called <code>ReWire.Interactive</code>:</p>
<pre><code class="language-haskell">λ&gt; pretty (f _40 _25 _20)
(48,37)
λ&gt; pretty (f _41 _25 _20)
(50,36)
λ&gt; 
</code></pre>
<h3 id="making-a-basic-carry-save-adder"><a class="header" href="#making-a-basic-carry-save-adder">Making a basic carry save adder</a></h3>
<pre><code class="language-haskell">-- |
-- | Example 1. CSA
-- |
-- | The only thing this does is take its inputs i, computes csa on them, and
-- | output the results every clock cycle.

csa :: (W 8, W 8, W 8) -&gt; ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
csa (a, b, c) = do
                   abc' &lt;- signal (f a b c)
                   csa abc'

start :: ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
start = csa (_0, _0, _0)
</code></pre>
<p>First, <code>csa</code> consumes its three inputs <code>a</code>, <code>b</code>, and <code>c</code> as a tuple. Then, it computes the carry save addition on these and puts the result on the output port, <code>signal (f a b c)</code>. Finally, it obtains the next inputs, <code>abc'</code> and continues.</p>
<p><em>What does the type of <code>csa</code> mean?</em> It's worth contemplating the type of <code>csa</code>'s codomain, which is <code>ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()</code>.</p>
<ul>
<li>The input type is <code>(W 8, W 8, W 8)</code>, meaning that every it takes three <code>W 8</code>s each clock cycle;</li>
<li>The output type is <code>(W 8, W 8)</code>, meaning that every it produces two <code>W 8</code>s each clock cycle; and</li>
<li>It does not use any internal storage or registers, hence the <code>Identity</code> monad is used rather than a state monad.</li>
</ul>
<h4 id="running-it-in-ghci"><a class="header" href="#running-it-in-ghci">Running it in GHCi</a></h4>
<p>You can run this using <code>pretty</code> and <code>runP</code> from <code>ReWire.Interactive</code>. First, define some inputs that look familiar:</p>
<pre><code class="language-haskell">inputs :: [(W 8 , W 8 , W 8)]
inputs = (_40 , _25 , _20)
       : (_41 , _25 , _20)
       : (_40 , _25 , _20)  : []
</code></pre>
<pre><code class="language-haskell">λ&gt; :t pretty
pretty :: Pretty a =&gt; a -&gt; IO ()
λ&gt; pretty $ runP start ((_0  , _0  , _0) , (_0  , _0 )) inputs
((0,0,0),(0,0)) :&gt; ((40,25,20),(0,0)) :&gt; ((41,25,20),(48,37)) :&gt; ((40,25,20),(50,36)) :+&gt; Nothing
</code></pre>
<p>(<strong>WARNING:</strong> <code>ReWire.Interactive</code> is currently in <em>super-king-kong-major-hacky</em> form right now.)</p>
<h4 id="compiling-it-with-rwc"><a class="header" href="#compiling-it-with-rwc">Compiling it with RWC</a></h4>
<p>First, here's the entire file as it stands:</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
import Prelude hiding ((^))
import ReWire
import ReWire.Bits

-- | ReWire compiler will complain if this is imported
import ReWire.Interactive

f :: W 8 -&gt; W 8 -&gt; W 8 -&gt; (W 8, W 8)
f a b c = ( ((a .&amp;. b) .|. (a .&amp;. c) .|. (b .&amp;. c) ) &lt;&lt;. lit 1 , (a ^ b) ^ c )

-- Constants for a running example.
_40 , _25 , _20 , _41 , _0 :: W 8
_40 = lit 40
_25 = lit 25
_20 = lit 20
_41 = lit 41
_0  = lit 0

-- |
-- | Example 1. CSA
-- |
-- | The only thing this does is take its inputs i, computes csa on them, and
-- | output the results every clock cycle.

csa :: (W 8, W 8, W 8) -&gt; ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
csa (a, b, c) = do
                   abc' &lt;- signal (f a b c)
                   csa abc'

start :: ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
start = csa (_0, _0, _0)

-- | ReWire compiler will complain if this is here (i.e., comment it before compiling):
inputs :: [(W 8 , W 8 , W 8)]
inputs = (_40 , _25 , _20)
       : (_41 , _25 , _20)
       : (_40 , _25 , _20)  : []
</code></pre>
<p><em>Pro-tip.</em> Because ReWire doesn't know about things likes lists, <code>ReWire.Interactive</code> and the definition of <code>inputs</code> need to be commented out <em>before</em> compiling with <code>rwc</code>. Otherwise, you will receive a non-informative error message like this:</p>
<pre><code class="language-haskell">$ rwc CSA.hs --verilog
Control/Monad/Identity.hs:
Error: File not found in load-path
$ 
</code></pre>
<p>Assuming these are now commented out, you can proceed to compile CSA.hs with:</p>
<pre><code class="language-haskell">$ ls -l CSA.* 
-rw-r--r--  1 william.harrison  staff  1039 Jun 13 09:02 CSA.hs
$ rwc CSA.hs --verilog
$ ls -l CSA.*         
-rw-r--r--  1 william.harrison  staff  1039 Jun 13 09:02 CSA.hs
-rw-r--r--  1 william.harrison  staff  2159 Jun 13 09:04 CSA.v
$ 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-processors"><a class="header" href="#simple-processors">Simple Processors</a></h1>
<p>This chapter describes several simple processors.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tiny-isa"><a class="header" href="#tiny-isa">Tiny ISA</a></h2>
<p>We now describe a simple processor with a tiny instruction set (hence the name <a href="chapters/chapter2/TinyISA.hs">TinyISA.hs</a>).</p>
<pre><code class="language-haskell">type W6    = W 6
type W8    = W 8
data Reg   = R0 | R1 | R2 | R3 
type Addr  = W6
data Instr = NOP
           | LD Addr
           | ST Addr
           | NAND Reg Reg Reg
           | BNZ Addr
</code></pre>
<pre><code class="language-haskell">data Ins     = Ins { instrIn :: Instr,
                     dataIn  :: W 8 }
data Out     = Out { weOut   :: Bit,
                     addrOut :: Addr,
                     dataOut :: W 8 }
data RegFile = RegFile { r0 :: W 8, r1 :: W 8, r2 :: W 8, r3 :: W 8,
                         pc :: Addr, inputs :: Ins, outputs :: Out }

type S   = StateT RegFile Identity
type Dev = ReacT Ins Out S
</code></pre>
<pre><code class="language-haskell">-- read, write, and increment the PC
getPC :: S Addr
getPC = do s &lt;- get
           return (pc s)
           
putPC :: Addr -&gt; S ()
putPC a = do s &lt;- get
             put (s { pc = a })

incrPC :: S ()
incrPC = do pc &lt;- getPC
            putPC (pc + lit 1)
</code></pre>
<pre><code class="language-haskell">-- read and write each register
getReg :: Reg -&gt; S (W 8)
getReg R0 = get &gt;&gt;= return . r0
getReg R1 = get &gt;&gt;= return . r1 
getReg R2 = get &gt;&gt;= return . r2 
getReg R3 = get &gt;&gt;= return . r3
            
putReg :: Reg -&gt; W 8 -&gt; S ()
putReg R0 b = get &gt;&gt;= \ s -&gt; put (s { r0 = b })
putReg R1 b = get &gt;&gt;= \ s -&gt; put (s { r1 = b })
putReg R2 b = get &gt;&gt;= \ s -&gt; put (s { r2 = b })
putReg R3 b = get &gt;&gt;= \ s -&gt; put (s { r3 = b })
</code></pre>
<pre><code class="language-haskell">getOut :: S Out
getOut   = do
             s &lt;- get
             return (outputs s) 

putOut :: Out -&gt; S ()
putOut o = do
             s &lt;- get
             put (s { outputs = o })

getIns :: S Ins
getIns   = do
             s &lt;- get
             return (inputs s)

getDataIn :: S (W 8)
getDataIn = do
              i &lt;- getIns
              return (dataIn i) 

getInstr :: S Instr
getInstr = do
             i &lt;- getIns
             return (instrIn i) 

putIns :: Ins -&gt; S ()
putIns i = do
             s &lt;- get
             put (s { inputs = i })

tick :: Dev ()
tick     = do o &lt;- lift getOut
              i &lt;- signal o
              lift (putIns i)

putWeOut :: Bit -&gt; S ()
putWeOut b = do o &lt;- getOut
                putOut (o { weOut = b })

putAddrOut :: Addr -&gt; S ()                       
putAddrOut a = do o &lt;- getOut
                  putOut (o { addrOut = a })

putDataOut :: W 8 -&gt; S ()                  
putDataOut d = do o &lt;- getOut
                  putOut (o { dataOut = d })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crossbar-switch"><a class="header" href="#crossbar-switch">Crossbar Switch</a></h1>
<h2 id="whats-a-crossbar-switch"><a class="header" href="#whats-a-crossbar-switch">What’s a Crossbar Switch?</a></h2>
<p>To perform this exercise, I relied primarily on two sources to explain what a crossbar switch is; they are:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Crossbar_switch">Wikipedia</a></li>
<li><a href="http://www.cs.emory.edu/~cheung/Courses/355/Syllabus/90-parallel/CrossBar.html">The Crossbar Switch</a></li>
</ul>
<p>Given these explanations, I generated a Haskell implementation of a crossbar switch like function (see CrossbarSwitch.hs below). All the Haskell and ReWire code for this example can be found below.</p>
<ul>
<li><a href="code/CrossbarSwitch.hs">CrossbarSwitch.hs</a></li>
</ul>
<p>What follows is an explanation of this code. First, we consider the Haskell definition of a crossbar switch, written in monadic style. Then, we transform the Haskell definition of the switch into proper ReWire. This is important because it gives you a practical introduction to the differences between Haskell and ReWire..</p>
<h3 id="just-write-it-in-haskell-first-then-add-a-few-bits-to-get-your-program-into-rewire"><a class="header" href="#just-write-it-in-haskell-first-then-add-a-few-bits-to-get-your-program-into-rewire">Just write it in Haskell first, then add a few bits to get your program into ReWire.</a></h3>
<p>The usual mode of program development is to first write a version of the desired application in Haskell using the concepts described in the Language Reference section. The reasons to do this boil down to the GHC compiler being vastly more mature than the ReWire compiler, and so, for example, error messages are much more informative. Once all the kinks as it were are worked out in Haskell (e.g., getting something that typechecks, etc.), make a number of small tweeks to get your program into the ReWire subset of Haskell. This section of the tutorial introduces the reader to this mode of program development.</p>
<h4 id="rewire-prelude"><a class="header" href="#rewire-prelude">ReWire Prelude</a></h4>
<p>In the same manner as the Glasgow Haskell Compiler and other Haskell implementations, we are compiling a list of standard definitions into a prelude file, ReWirePrelude.hs. This file is, in effect, a dirty snowball of definitions that we are accumulating with the intent of ultimately making it part of the standard ReWire implementation. For now, to use it, you must explicitly import it.</p>
<p>ReWirePrelude.hs includes definitions for bits (Bit) and words of various sizes (e.g., W8 and W32) as well as functions on those primitive types (e.g., rotateR2). The particular file we use can be found here.</p>
<p>What follows is a crossbar switch function written in Haskell. We will take this as an input specification, by which we mean that it is not terribly important to actually understand what the crossbar function is calculating. Rather, what is interesting is what must change in this specification to transform it into a proper ReWire specification.</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}

import Prelude hiding ((^), (+))
import ReWire

switch :: t -&gt; t -&gt; Bool -&gt; (t, t)
switch x _ True  = (x,x)
switch x y False = (x,y)

type W8 = W 8

data Maybe4 = Maybe4 (Maybe W8) (Maybe W8) (Maybe W8) (Maybe W8)

type Bool16 = (Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool)

crossbar :: Maybe4 -&gt; Bool16 -&gt; Maybe4 
crossbar (Maybe4 x10 x20 x30 x40) (c11,c12,c13,c14,c21,c22,c23,c24,c31,c32,c33,c34,c41,c42,c43,c44)
   = let
          (x41,y31) = switch x40 Nothing c41
          (x42,y32) = switch x41 Nothing c42
          (x43,y33) = switch x42 Nothing c43
          (_,y34) = switch x43 Nothing c44

          (x31,y21) = switch x30 y31 c31
          (x32,y22) = switch x31 y32 c32
          (x33,y23) = switch x32 y33 c33
          (_,y24) = switch x33 y34 c34

          (x21,y11) = switch x20 y21 c21
          (x22,y12) = switch x21 y22 c22
          (x23,y13) = switch x22 y23 c23
          (_,y14) = switch x23 y24 c24

          (x11,y10) = switch x10 y11 c11
          (x12,y20) = switch x11 y12 c12
          (x13,y30) = switch x12 y13 c13
          (_,y40) = switch x13 y14 c14
     in
       Maybe4 y10 y20 y30 y40

data Inp = Inp Maybe4 Bool16 | NoInput
            
data Out = Out Maybe4 | Nix

dev :: Inp -&gt; ReacT Inp Out Identity ()
dev (Inp m4 b16) = signal (Out (crossbar m4 b16)) &gt;&gt;= dev
dev NoInput      = signal Nix &gt;&gt;= dev

start :: ReacT Inp Out Identity ()
start = signal Nix &gt;&gt;= dev
</code></pre>
<p>Crossbar Switch in ReWire
This section considers the ReWire version of the crossbar switch. The whole code is available here. These two implementations are almost the same, but there are differences. We will go through the code in detail to highlight the differences.</p>
<p>Here we have commented out the module and import declarations, except for the ReWirePrelude. The main ReWire file does not belong in a module. Note that the monad definitions from Control.Monad are built-in to ReWire, and so, they should not be imported.</p>
<p>{-
module CrossbarSwitch where</p>
<p>import Control.Monad.Identity
import Control.Monad.State
import Control.Monad.Resumption.Reactive</p>
<p>type I = Identity
-}</p>
<p>import ReWirePrelude
Note that the switch function has polymorphic type below. ReWire does not allow polymorphically typed expressions, and so, for that reason, we use an INLINE directive. This directive informs the ReWire frontend to inline that function wherever it occurs. This has the effect of eliminating the polymorphic function. An alternative would be to simply rewrite the type declaration of switch so that it had a simple (i.e., variable free) type. Note also that the Maybe4 declaration is written with no free variables; i.e., Maybe4 isn’t polymorphic either.</p>
<p>It is worth emphasizing that each function declaration in ReWire must have an accompanying type declaration.</p>
<p>switch :: t -&gt; t -&gt; Bool -&gt; (t, t)
{-# INLINE switch #-}
switch x y True  = (x,x)
switch x y False = (x,y)</p>
<p>data Maybe4 = Maybe4 (Maybe W8) (Maybe W8) (Maybe W8) (Maybe W8)
The code for crossbar below has several changes. For one, it is no longer declared with a let declaration, but rather uses an equivalent where formulation. Semantically, where and let are equivalent; that is, let <binding-group> in e is equvalent to e where <binding-group>. But, as of this writing, let has not been implemented in the ReWire compiler as yet (it is on a lengthy to-do list of simple extensions). There is another slightly more substantial difference. The clauses in the where declaration have been rearranged in order of dependency. These binding clauses are processed in-order (in the manner of, say, OCaml) rather than as a group (as in Haskell). This is a ReWire bug/feature which also appears on the aforementioned to-do list. Note that we have also dispensed with the type synonym Bool16. Type synonyms are on our to-do list.</p>
<p>crossbar :: Maybe4                                                                            -&gt;
(Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool) -&gt;
Maybe4
crossbar (Maybe4 x10 x20 x30 x40) (c11,c12,c13,c14,c21,c22,c23,c24,c31,c32,c33,c34,c41,c42,c43,c44)
= Maybe4 y10 y20 y30 y40
where
(x41,y31) = switch x40 Nothing c41
(x31,y21) = switch x30 y31 c31
(x21,y11) = switch x20 y21 c21
(x42,y32) = switch x41 Nothing c42
(x32,y22) = switch x31 y32 c32
(x22,y12) = switch x21 y22 c22
(x11,y10) = switch x10 y11 c11
(x12,y20) = switch x11 y12 c12
(x43,y33) = switch x42 Nothing c43
(x33,y23) = switch x32 y33 c33
(x23,y13) = switch x22 y23 c23
(x13,y30) = switch x12 y13 c13
(x44,y34) = switch x43 Nothing c44
(x34,y24) = switch x33 y34 c34
(x24,y14) = switch x23 y24 c24
(x14,y40) = switch x13 y14 c14
Below are the input and output types for the device, Inp and Out. One thing that stands out style-wise when compared to Haskell is that we don’t use a type synonym for the long tuple of Bools. In Haskell, one would typically write something like type Bool16 = (Bool,...,Bool) just for syntactic convenience. As it stands, type synonyms are unimplemented in ReWire. This is, again, on the aforementioned to-do list of simple extensions to ReWire.</p>
<p>data Inp = Inp Maybe4<br />
(Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool,Bool)
| NoInput</p>
<p>data Out = Out Maybe4 | Nix
Below is the device declaration. The built-in identity monad in ReWire is written I (rather than Identity that was imported from Control.Monad in the Haskell version). Note that the dev has been replaced by the semantically equivalent \ i -&gt; dev i below. This is because ReWire is a 1st-order language and you cannot pass the function dev to the other function &gt;&gt;=. It is a focus of current research to extend ReWire to higher-order.</p>
<p>devcrossbar :: ReT Inp Out I ()
devcrossbar = signal Nix &gt;&gt;= \ i -&gt; dev i</p>
<p>dev :: Inp -&gt; ReT Inp Out I ()
dev (Inp m4 b16) = signal (Out (crossbar m4 b16)) &gt;&gt;= \ i -&gt; dev i
dev NoInput      = signal Nix &gt;&gt;= \ i -&gt; dev i
Last, but not least, is that every ReWire specification must contain a start declaration. The start symbol must have type ReT Inp Out I ().</p>
<p>start :: ReT Inp Out I ()
start = devcrossbar
Compiling with the ReWire Compiler
Once the ReWire specification is complete, we can compile with the ReWire compiler rwc:</p>
<p>bill$ rwc RWCrossbar.hs -o RWC.vhd
bill$ ls -l RWC.vhd
-rwxr-xr-x  1 bill  staff  61024 Jun 14 14:11 RWC.vhd
Note that, depending how successfully one’s translation into ReWire is, one may receive error messages fro the ReWire compiler. These are improving, although there is admittedly much room for improvement as of this writing.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
