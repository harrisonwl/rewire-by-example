<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ReWire by Example</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ReWire by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rewire-by-example"><a class="header" href="#rewire-by-example">ReWire by Example</a></h1>
<p>The ReWire functional high-level synthesis language (see below) is a functional language for designing, verifying, and implementing high assurance hardware.</p>
<ul>
<li>A hardware design in ReWire is also a Haskell program, and development of ReWire designs benefits from immediate feedback from its strong, static type system.</li>
<li>As with Rust, ReWire's type system enforces invariants and guarantees at compile-time, thereby eliminating whole classes of bugs statically in a lightweight, automated manner.</li>
<li>ReWire's type system can be extended by embedding designs into assurance tools (like Coq) to capture broad of automated checks and proof tools.</li>
<li>ReWire designs can be compiled into Verilog and thereby interoperate with synthesis tools.</li>
</ul>
<p align="center"><img src="./ReWireUses.jpg"  style="height:50%; width:50%" ></p>
<p>ReWire is not a replacement for commodity hardware design languages like Verilog but rather it is a value-add for hardware design, implementation, and verification that interoperates with them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-0-before-you-start"><a class="header" href="#chapter-0-before-you-start">Chapter 0: Before You Start</a></h1>
<p>These are the tutorial notes for the ReWire language.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="haskell"><a class="header" href="#haskell">Haskell</a></h3>
<p>There's no way of learning ReWire without knowing basic Haskell. I'm a Mac guy so I would use <code>homebrew</code> as in</p>
<ul>
<li><code>brew install ghc</code>. This will install the Glasgow Haskell Compiler.</li>
<li><code>brew install stack</code>. Stack is a tool for installing haskell packages. It really makes things easy (well, easier).</li>
</ul>
<h3 id="installing-rewire"><a class="header" href="#installing-rewire">Installing ReWire</a></h3>
<p>ReWire is freely available. Here is the repository where you find the most recent version: <a href="https://github.com/twosixlabs/ReWire">ReWire source</a>. Follow the directions -- <code>stack</code> makes it easy.</p>
<ul>
<li>This installation will build the ReWire compiler <code>rwc</code> and</li>
<li>Install libraries (aka <code>ReWire-user</code>) that allow you to program in ReWire with the Haskell interpreter <code>ghci</code>.</li>
</ul>
<h3 id="monads-in-haskell"><a class="header" href="#monads-in-haskell">Monads in Haskell</a></h3>
<p>You have to be comfortable with the basics of "monad wrangling". You don't need to understand them in any great depth, but understanding the following ought to do:</p>
<ol>
<li>The <code>Identity</code> monad;</li>
<li>the state monad; and</li>
<li>the <code>Maybe</code> monad.</li>
</ol>
<p>Understanding the basic usage of the <code>StateT</code> monad transformer is important. It's a shame that they are known as "transformer" instead of "constructor", because all a monad transformer is is a way to construct monads in a canonical fashion.</p>
<p>Monads are a concept from Category Theory. I love Category Theory, really I do. But I'd <strong>strongly</strong> recommend avoiding categorical treatments of monads if this is your first time with this material. Rather, check out Graham Hutton or Miran Lipovaca's texts as they're both excellent.</p>
<h4 id="reactive-resumption-monads"><a class="header" href="#reactive-resumption-monads">Reactive Resumption Monads</a></h4>
<p>These are a particular family of monads that can be used to precisely describe synchronous concurrency (e.g., like clocked computations in hardware). They sound scary, but they're not. Check out the following papers of mine for the basics if you want. I suspect a lot of readers will just look at its usage in ReWire and get them well enough.</p>
<ol>
<li><a href="https://bibbase.org/network/publication/harrison-theessenceofmultitasking-2006">Essence of Multitasking</a> and</li>
<li><a href="https://bibbase.org/network/publication/harrison-procter-cheapbutfunctionalthreads-2015">Cheap (But Functional) Threads</a>.</li>
</ol>
<p>These monads are implemented in the Hackage package <a href="https://hackage.haskell.org/package/monad-resumption">monad-resumption</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="haskell-1"><a class="header" href="#haskell-1">Haskell</a></h2>
<p>Here are some good sources:</p>
<ul>
<li><strong>Programming in Haskell</strong> by Graham Hutton.
This is an excellent, step-by-step introduction to Haskell. Graham also has a lot of online resources (slides, videos, etc.) to go along with the book.</li>
<li><strong>Learn You a Haskell for Good</strong> by Miran Lipovaca.
Highly amusing and informative; available <a href="https://learnyouahaskell.com/">here</a>.</li>
<li><strong>A Gentle Introduction to Haskell</strong> by Hudak, Peterson, and Fasal.
Available at <a href="http://www.haskell.org/tutorial/">http://www.haskell.org/tutorial/</a>.</li>
<li><strong>Real World Haskell</strong> by Bryan O'Sullivan.
Also available online (I believe).</li>
<li>Google.</li>
<li><strong>Haskell for Grownups</strong>. These are some slides (<a href="chapters/chapter0/HaskellForGrownups.pdf">HaskellForGrownups.pdf</a>) I've presented here and there over the years as a quick intro to Haskell and what all the fuss is about.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monad-wrangling-101"><a class="header" href="#monad-wrangling-101">Monad Wrangling 101</a></h1>
<p>ReWire is a monadic language, meaning that it is organized in terms of various monads (which ones, we'll get to shortly). There are about a zillion tutorials on monads out there, and most of them are just <em>terrible</em>. This is a shame since the idea of a monad itself is really beautiful and, if you know how to use them correctly, they're a really important part of functional programming practice. And, furthermore, they are a really important part of programming language semantics, too, and consequently an important part of formal methods properly understood.</p>
<p>What this section does is introduce the monad idea through a sequence of simple language interpreters. As we add features to the language, we have to change the monad we use to define the new interpreter. We will see four interpreters whose core is a language of simple arithmetic expressions.</p>
<p>To see all of the monads discussed in this tutorial defined in one convenient Haskell file, download this:
<a href="chapters/chapter0/monadwrangling/MonadWrangling.hs">MonadWrangling.hs</a>. These monad and monad transformer definitions are in the style of earlier versions of GHC, which were immensely easier to understand than the current mess.</p>
<hr />
<h2 id="simple-arithmetic-expressions"><a class="header" href="#simple-arithmetic-expressions">Simple Arithmetic Expressions</a></h2>
<p>The first interpreter, found in <a href="chapters/chapter0/monadwrangling/Arith.hs">Arith.hs</a>, defines a language <code>Exp</code> that has integer constants, negation, and addition. These correspond to the constructors <code>Const</code>, <code>Neg</code>, and <code>Add</code> of the <code>Exp</code> data type. The interpreter <code>eval0</code> does not use a monad and should be fairly self-explanatory.</p>
<pre><code class="language-haskell">module Arith where

data Exp = Const Int | Neg Exp | Add Exp Exp

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2

eval0 :: Exp -&gt; Int
eval0 (Const i)   = i
eval0 (Neg e)     = - (eval0 e)
eval0 (Add e1 e2) = eval0 e1 + eval0 e2

c = Const 99
n = Neg c
a = Add c n
</code></pre>
<p>Loading this into GHCi gives you what you'd expect:</p>
<pre><code>λ&gt; a
99 + -99
λ&gt; eval0 a
0
</code></pre>
<hr />
<h2 id="the-identity-monad-is-a-big-nothingburger"><a class="header" href="#the-identity-monad-is-a-big-nothingburger">The <code>Identity</code> Monad is a Big Nothingburger</a></h2>
<p>We introduce now the <code>Identity</code> monad, which doesn't really give you anything at all. I introduce it first because it uses Haskell's built-in monad syntax, and it's useful to meet that syntax first when the monad is just a big nothing. The code for this section is found in <a href="chapters/chapter0/monadwrangling/IdentityMonad.hs">IdentityMonad.hs</a> and <a href="chapters/chapter0/monadwrangling/IdentityMonadDo.hs">IdentityMonadDo.hs</a>.</p>
<p>First, here's the new interpreter <code>eval1</code>. The salient point is that <code>eval0</code> and <code>eval1</code> are doing the same thing, but what's all this <code>return</code> and <code>&gt;&gt;=</code> business? (They're explained below if you want to skip ahead.)</p>
<pre><code class="language-haskell">module IdentityMonad where

import Control.Monad.Identity -- this is new.

data Exp = Const Int | Neg Exp | Add Exp Exp

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2

eval1 :: Exp -&gt; Identity Int
eval1 (Const i)   = return i
eval1 (Neg e)     = eval1 e &gt;&gt;= \ v -&gt; return (- v)
eval1 (Add e1 e2) = eval1 e1 &gt;&gt;= \ v1 -&gt; eval1 e2 &gt;&gt;= \ v2 -&gt; return (v1 + v2)

c = Const 99
n = Neg c
a = Add c n
</code></pre>
<p>The <code>Identity</code> monad has the following definition (it's actually a simplification).</p>
<pre><code class="language-haskell">data Identity a = Identity a -- apologies for overloading the constructors.
return :: a -&gt; Identity a
return v = Identity v
(&gt;&gt;=) :: Identity a -&gt; (a -&gt; Identity b) -&gt; Identity b
(Identity v) &gt;&gt;= f = f v
</code></pre>
<p>So, <code>return</code> just injects its argument into <code>Identity</code>. The operation <code>&gt;&gt;=</code> (a.k.a., "bind") boils down to a backwards apply. It's just a whole lot of applying and pattern-matching on the <code>Identity</code> constructor, signifying nothing. When you load all this into GHCi, you get just what you'd expect:</p>
<pre><code>λ&gt; a
99 + -99
λ&gt; eval1 a
Identity 0
λ&gt; 
</code></pre>
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<p>As people say, <code>eval1</code> and <code>eval0</code> are morally equivalent, in the sense that, if you were so inclined, you could <em>prove</em> the equality <code>eval1 a = Identity (eval0 a)</code> holds for any <code>a</code>.</p>
<h3 id="monadic-syntactic-sugar-or-saccharine"><a class="header" href="#monadic-syntactic-sugar-or-saccharine">Monadic Syntactic Sugar or Saccharine?</a></h3>
<p>Haskell overloads its monad syntax, so when we see the <code>&gt;&gt;=</code> and <code>return</code> again, they will be typed in different monads than <code>Identity</code>. Overloading is great for some uses, because it removes clutter. I find for formal methods it can be kind of confusing. So, reader beware!</p>
<p>There is also another shorthand for <code>&gt;&gt;=</code> that is frequently used called <code>do</code> notation; it's defined as:</p>
<pre><code class="language-haskell">   x &gt;&gt;= f = do
               v &lt;- x
		       f v
</code></pre>
<p>So, the clause of <code>eval1</code> for <code>Neg</code> is as follows when written in <code>do</code> notation:</p>
<pre><code class="language-haskell">eval1 (Neg e)     = do
                      v &lt;- eval1 e
                      return (- v)
</code></pre>
<p>The code <code>IdentityMonadDo.hs</code> just reformulates the code in <code>IdentityMonad.hs</code> using <code>do</code> notation.</p>
<hr />
<h2 id="2nd-interpreter-errors-and-maybe"><a class="header" href="#2nd-interpreter-errors-and-maybe">2nd Interpreter: Errors and Maybe</a></h2>
<p>The code for this section is found in <a href="chapters/chapter0/monadwrangling/Errors.hs">Errors.hs</a>. This new interpreter adds a new arithmetic operation <code>Div</code>. I pasted in the <code>eval0</code> with a new case for <code>Div</code>.</p>
<pre><code class="language-haskell">module Errors where

data Exp = Const Int | Neg Exp | Add Exp Exp
         | Div Exp Exp                      -- new

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2
  show (Div e1 e2) = show e1 ++ " / " ++ show e2

-- | Same as before, but with a new case
eval0 :: Exp -&gt; Int
eval0 (Const i)   = i
eval0 (Neg e)     = - (eval0 e)
eval0 (Add e1 e2) = eval0 e1 + eval0 e2
eval0 (Div e1 e2) = eval0 e1 `div` eval0 e2 -- new

a    = Add c (Neg c)
        where
          c = Const 99
uhoh = Div (Const 1) (Const 0)              -- new
</code></pre>
<p>Note that, when you run the <code>Div</code>-extended version of <code>eval0</code>, things don't always end well:</p>
<pre><code class="language-haskell">λ&gt; uhoh
1 / 0
λ&gt; eval0 uhoh
*** Exception: divide by zero
λ&gt; 
</code></pre>
<h3 id="why-cant-we-just-check-for-0"><a class="header" href="#why-cant-we-just-check-for-0">Why can't we just check for 0?</a></h3>
<p>Think about it this way, what should I replace <code>????</code> with below? There's no way of handling that exceptional case and it crashes the program.</p>
<pre><code class="language-haskell">eval0 (Div e1 e2) = if v2 == 0 then ???? else eval0 e1 `div` v2 
   where
      v2 = eval0 e2
</code></pre>
<p>But with the <code>Maybe</code> monad, we can use its <code>Nothing</code> constructor for this erroneous case; recall the definition of the <code>Maybe</code> data type:</p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p>Here's the definition of <code>eval2</code> whhich is typed in the <code>Maybe</code> monad:</p>
<pre><code class="language-haskell">eval2 :: Exp -&gt; Maybe Int     -- N.b., the new type
eval2 (Const i)   = return i
eval2 (Neg e)     = do
                      v &lt;- eval2 e
                      return (- v)
eval2 (Add e1 e2) = do
                      v1 &lt;- eval2 e1
                      v2 &lt;- eval2 e2
                      return (v1 + v2)
eval2 (Div e1 e2) = do
                      v1 &lt;- eval2 e1
                      v2 &lt;- eval2 e2
                      if v2==0 then Nothing else return (v1 `div` v2) -- fill in ???? with Nothing
</code></pre>
<pre><code class="language-haskell">λ&gt; uhoh
1 / 0
λ&gt; eval2 uhoh
Nothing
</code></pre>
<h3 id="maybe-under-the-hood"><a class="header" href="#maybe-under-the-hood">Maybe Under the Hood</a></h3>
<p>Below is the definition of the <code>Maybe</code> monad. The way to think of a computation <code>x &gt;&gt;= f</code> is that, if <code>x</code> is returns some value (i.e., it's <code>Just v</code>), then just proceed normally. If an exception is thrown by computing <code>x</code> (i.e., it's <code>Nothing</code>), then the whole computation <code>x &gt;&gt;= f</code></p>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a

return :: a -&gt; Maybe a
return v = Just v

(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b 
(Just v) &gt;&gt;= f = f v
Nothing &gt;&gt;= f  = Nothing
</code></pre>
<hr />
<h1 id="3rd-interpreter-adding-a-register"><a class="header" href="#3rd-interpreter-adding-a-register">3rd Interpreter: Adding a Register</a></h1>
<p>The code for this section is <a href="chapters/chapter0/monadwrangling/Register.hs">Register.hs</a>.</p>
<pre><code class="language-haskell">module Register where

import Control.Monad.State

data Exp = Const Int | Neg Exp | Add Exp Exp
         | X  -- new register X

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2
  show X           = "X"

-- | Just a copy 
eval2 :: Exp -&gt; Maybe Int
eval2 (Const i)   = return i
eval2 (Neg e)     = do
                      v &lt;- eval2 e
                      return (- v)
eval2 (Add e1 e2) = do
                      v1 &lt;- eval2 e1
                      v2 &lt;- eval2 e2
                      return (v1 + v2)

eval2 X           = undefined -- How do we do handle this?
</code></pre>
<p>Here's how we handle this:</p>
<ul>
<li>Create a new monad from <code>Identity</code> with an <code>Int</code> register: <code>StateT Int Identity</code></li>
<li>This new monad has two operations
<ul>
<li><code>get</code> that reads the current value of the register</li>
<li><code>put</code> that updates the value of the register</li>
</ul>
</li>
<li><code>StateT Int</code> is known as a <em>monad transformer</em></li>
</ul>
<p>The code below does just that</p>
<pre><code class="language-haskell">readX :: StateT Int Identity Int
readX = get

eval3 :: Exp -&gt; StateT Int Identity Int
eval3 (Const i)   = return i
eval3 (Neg e)     = do
                      v &lt;- eval3 e
                      return (- v)
eval3 (Add e1 e2) = do
                      v1 &lt;- eval3 e1
                      v2 &lt;- eval3 e2
                      return (v1 + v2)

eval3 X           = readX
</code></pre>
<hr />
<h1 id="4th-errors--register"><a class="header" href="#4th-errors--register">4th: Errors + Register</a></h1>
<p>The code for this is <a href="chapters/chapter0/monadwrangling/RegisterError.hs">RegisterError.hs</a>. In this example, we want to add both a possibly error-producing computation along with the register. This is done mostly through monadic means.</p>
<pre><code class="language-haskell">module Register where

import Control.Monad.State

data Exp = Const Int | Neg Exp | Add Exp Exp
         | Div Exp Exp  -- Both errors
         | X            -- and a register X

instance Show Exp where
  show (Const i) = show i
  show (Neg e)   = "-" ++ show e
  show (Add e1 e2) = show e1 ++ " + " ++ show e2
  show (Div e1 e2) = show e1 ++ " / " ++ show e2
  show X           = "X"
</code></pre>
<p>Here's how we handle this:</p>
<ul>
<li>Create a new monad from <code>Maybe</code> with an <code>Int</code> register: <code>StateT Int Maybe</code></li>
<li>This new monad has two operations
<ul>
<li><code>get</code> that reads the current value of the register</li>
<li><code>put</code> that updates the value of the register</li>
</ul>
</li>
<li><code>StateT Int</code> is known as a <em>monad transformer</em></li>
</ul>
<p>The code below does just that</p>
<pre><code class="language-haskell">readX :: StateT Int Maybe Int
readX = get

eval3 :: Exp -&gt; StateT Int Maybe Int
eval3 (Const i)   = return i
eval3 (Neg e)     = do
                      v &lt;- eval3 e
                      return (- v)
eval3 (Add e1 e2) = do
                      v1 &lt;- eval3 e1
                      v2 &lt;- eval3 e2
                      return (v1 + v2)
eval3 (Div e1 e2) = do
                      v1 &lt;- eval3 e1
                      v2 &lt;- eval3 e2
                      if v2==0 then lift Nothing else return (v1 `div` v2)
                                 -- N.b., this is new.

eval3 X           = readX
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-worlds"><a class="header" href="#hello-worlds">Hello Worlds</a></h1>
<p>This first chapter introduces ReWire and collects the simplest possible examples.</p>
<h2 id="what-is-rewire"><a class="header" href="#what-is-rewire">What is ReWire?</a></h2>
<p>ReWire is a domain-specific language embedded in the Haskell functional programming language (<a href="https://haskell.org">https://haskell.org</a>). <em>Every</em> ReWire program is a Haskell program that can be executed just as any other Haskell program. This fact is simple and also very powerful, because it means that development of a hardware design can proceed <em>incrementally</em>, one function at a time, with the resulting new code being type-checked and/or tested. Once a developer is satisfied with their ReWire design, they can compile it automatically into synthesizable HDLs (hardware definition languages) like Verilog, VHDL, and FIRRTL.</p>
<img src="chapters/chapter1/images/ReWireInColor.png"  style="height:60%; width:60%" >
<h3 id="mealy-machines-and-rewire-types"><a class="header" href="#mealy-machines-and-rewire-types">Mealy Machines and ReWire types</a></h3>
<p>There's a mental model of digital circuitry used by hardware designers known as a Mealy machine. The flavor favored by hardware designers is portrayed below, which will seem odd to those of us who first heard of them from a class in theoretical computer science (e.g., <a href="https://en.wikipedia.org/wiki/Mealy_machine">https://en.wikipedia.org/wiki/Mealy_machine</a>). Mealy machines are finite state machines combined with a clock that on each clock "tick" consume an input of type <code>i</code>, update a store of type <code>s</code>, and produce an output of type <code>o</code>.</p>
<img src="chapters/chapter1/images/beautifullestmealy.png"  style="height:50%; width:50%" >
<p>In ReWire, there is a type corresponding to the Mealy machine above, the monadic type:</p>
<p><code>ReacT i o (StateT s Identity) ()</code></p>
<p>And, because it occurs so frequently, we refer to it as a <em>device type</em> some times. Things of this type are those that can be compiled to hardware.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="simple-mealy"><a class="header" href="#simple-mealy">Simple Mealy</a></h2>
<p>The "theoretical computer science" picture of a Mealy machine is seen below:</p>
<img src="chapters/chapter1/images/Mealy.png"  style="height:17%; width:17%" >
<p>Here <code>si</code> is the start state, and there are two other states, <code>s0</code> and <code>s1</code>. There is also an alphabet consisting of <code>0</code> and <code>1</code>. On the transitions, a red digit denotes an input and a blue digit denotes an output, so, in the machine is currently in state <code>si</code> and receives a <code>1</code> as input, it outputs a <code>0</code> and proceeds to state <code>s1</code>.</p>
<p>The ReWire code described in the section is found here, <a href="chapters/chapter1/SimpleMealy.hs">SimpleMealy.hs</a>, and what follows is a line-by-line description.</p>
<p>First thing is to import a library with ReWire definitions, etc. What's <code>DataKinds</code>? Don't worry about it for now. Collected in a comment is a tabular form of the state transitions.</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
import ReWire

-- Current State | Input | Output | Next State
-- --------------------------------------------
--    si             0       0          s0
--    si             1       0          s1
--    s0             0       0          s0
--    s0             1       1          s1
--    s1             0       1          s0
--    s1             1       0          s1
</code></pre>
<p>Next, let's define the alphabet:</p>
<pre><code class="language-haskell">data Alphabet = Zero | One
</code></pre>
<p><code>Alphabet</code> defines both the inputs and outputs of this Mealy machine.</p>
<p>Each of the three states and their transitions are defined in the following. Before focusing on the type, note first how each line below corresponds directly to a line in the table above. E.g., if the machine is in state <code>si</code> and receives <code>0</code> as input, it produces output <code>0</code>, and proceeds to state <code>s0</code>.</p>
<pre><code class="language-haskell">si , s0 , s1 :: Alphabet -&gt; ReacT Alphabet Alphabet Identity ()

si Zero = signal Zero &gt;&gt;= s0
si One  = signal Zero &gt;&gt;= s1

s0 Zero = signal Zero &gt;&gt;= s0
s0 One  = signal One  &gt;&gt;= s1

s1 Zero = signal One  &gt;&gt;= s0
s1 One  = signal Zero &gt;&gt;= s1
</code></pre>
<p>We'll return to the types of <code>si</code>, <code>s0</code>, and <code>s1</code> momentarily.</p>
<p>Finally, we need to designate a start state, just as with any state machine definition.</p>
<pre><code class="language-haskell">start :: ReacT Alphabet Alphabet Identity ()
start = signal Zero &gt;&gt;= si
</code></pre>
<h4 id="why-this-type-react-alphabet-alphabet-identity-"><a class="header" href="#why-this-type-react-alphabet-alphabet-identity-">Why this type <code>ReacT Alphabet Alphabet Identity ()</code>?</a></h4>
<p>We know the type will have the form <code>ReacT i o m a</code> for some types <code>i</code>, <code>o</code>, and <code>a</code> and monad <code>m</code>.</p>
<ul>
<li>The input alphabet is <code>Alphabet</code>, so <code>i</code> is <code>Alphabet</code>.</li>
<li>The output alphabet is <code>Alphabet</code>, so <code>o</code> is also <code>Alphabet</code>.</li>
<li>We are not using internal storage like registers, so monad <code>m</code> can be just <code>Identity</code>.</li>
</ul>
<p>Finally, why <code>()</code> for return type <code>a</code>? Here, we have a choice, but it doesn't matter in the least what we pick. Because <code>start</code> never, ever, terminates under any circumstances, it won't ever return any value, so we may as well pick <code>()</code>.</p>
<p>This non-termination requirement on <code>start</code> is important and makes complete sense if you think about it. Hardware <strong>never</strong> terminates (unless it's unplugged).</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-obligatory-fibonacci-example"><a class="header" href="#the-obligatory-fibonacci-example">The Obligatory Fibonacci Example</a></h2>
<p>The following Haskell code (the file is called <a href="chapters/chapter1/Fib.hs">Fib.hs</a>) creates an infinite list of <code>Int</code>s in a conventional manner using the <code>fibgen</code> function.</p>
<pre><code class="language-haskell">module Fibonacci where

fibs :: [Int]
fibs = fibgen 0 1
  where
    fibgen :: Int -&gt; Int -&gt; [Int]
    fibgen n m = n : fibgen m (n + m)
</code></pre>
<p>Loading <code>Fib.hs</code> into GHCi, you can see that it calculates the familiar Fibonacci sequence:</p>
<pre><code class="language-haskell">ghci&gt; take 10 fibs
take 10 fibs
[0,1,1,2,3,5,8,13,21,34]
</code></pre>
<h3 id="making-hardware-out-of-this"><a class="header" href="#making-hardware-out-of-this">Making Hardware Out of This.</a></h3>
<p>In the ReWire code below, <code>fibdev</code> plays the same role as <code>fibgen</code> above. For the moment, just ignore the monadic type, <code>ReacT Bit (W 8) Identity ()</code>. (I'll explain its significance shortly.) Instead of using Haskell's <code>Int</code> type, we will compute over eight bit words (i.e., <code>W 8</code>). There is also a definition of <code>start</code>, which is a special symbol that unsurprisingly specifies how to start the device.</p>
<p>What <code>fibdev</code> does is, given two words <code>n</code> and <code>m</code>, it puts <code>n</code> on the output port using <code>signal</code> and accepts a new input <code>b</code> off of the input port. If bit <code>b</code> is <code>1</code>, then it continues on. However, if <code>b</code> is <code>0</code>, then it calls itself on <code>m</code> and <code>m + n</code> just like <code>fibgen</code> above.</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
import Prelude hiding ((+))
import ReWire
import ReWire.Bits

start :: ReacT Bit (W 8) Identity ()
start = fibdev (lit 0) (lit 1)

fibdev :: W 8 -&gt; W 8 -&gt; ReacT Bit (W 8) Identity ()
fibdev n m = do b &lt;- signal n
                if b then fibdev n m else fibdev m (n + m)
</code></pre>
<h3 id="lessons-learned-1"><a class="header" href="#lessons-learned-1">Lessons Learned.</a></h3>
<p>There are some lessons to be learned from this example.</p>
<ul>
<li>Just like a state machine, every ReWire device has to have a <code>start</code>.</li>
<li>Most ReWire programs will begin with something like the top three lines of the previous ReWire code.
<ul>
<li>There may be Haskell <code>Prelude</code> operations that have a particular meaning in ReWire (e.g., <code>+</code>), and so they may need to be hidden explicitly.</li>
<li>The other parts of that incantation is performed to use built-in words and their operations.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="carry-save-addition"><a class="header" href="#carry-save-addition">Carry Save Addition</a></h2>
<p>There are three carry-save adders in the tutorial, <a href="chapters/chapter1/CSA.hs">CSA.hs</a>, <a href="chapters/chapter1/SCSA.hs">SCSA.hs</a>, and <a href="chapters/chapter1/PCSA.hs">PCSA.hs</a>, and the first of these is explained in detail below.</p>
<p>Carry save addition (<a href="https://en.wikipedia.org/wiki/Carry-save_adder">https://en.wikipedia.org/wiki/Carry-save_adder</a>) is defined as function <code>f</code>:</p>
<pre><code class="language-haskell">f :: W 8 -&gt; W 8 -&gt; W 8 -&gt; (W 8, W 8)
f a b c = ( ((a .&amp;. b) .|. (a .&amp;. c) .|. (b .&amp;. c) ) &lt;&lt;. lit 1 , (a ^ b) ^ c )
</code></pre>
<p>Here, I define <code>f</code> using ReWire's built-in word constructor, picking <code>W 8</code> for the sake of concreteness.
I'll define a few constants for convenience in a running example.</p>
<pre><code class="language-haskell">_40 , _25 , _20 , _41 , _0 :: W 8
_40 = lit 40
_25 = lit 25
_20 = lit 20
_41 = lit 41
_0  = lit 0
</code></pre>
<p>Using GHCi, we can test it out, like any Haskell function:</p>
<pre><code class="language-haskell">λ&gt; :t f
f :: W 8 -&gt; W 8 -&gt; W 8 -&gt; (W 8, W 8)
λ&gt; f _40 _25 _20
(Vector [False,False,True,True,False,False,False,False],Vector [False,False,True,False,False,True,False,True])
</code></pre>
<p>What's this mess? <code>W 8</code> values are represented internally using Haskell's <code>Data.Vector</code> library and, well, it ain't pretty. There is a ReWire library you can import to make all this more palatable called <code>ReWire.Interactive</code>:</p>
<pre><code class="language-haskell">λ&gt; pretty (f _40 _25 _20)
(48,37)
λ&gt; pretty (f _41 _25 _20)
(50,36)
λ&gt; 
</code></pre>
<h3 id="making-a-basic-carry-save-adder"><a class="header" href="#making-a-basic-carry-save-adder">Making a basic carry save adder</a></h3>
<pre><code class="language-haskell">-- |
-- | Example 1. CSA
-- |
-- | The only thing this does is take its inputs i, computes csa on them, and
-- | output the results every clock cycle.

csa :: (W 8, W 8, W 8) -&gt; ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
csa (a, b, c) = do
                   abc' &lt;- signal (f a b c)
                   csa abc'

start :: ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
start = csa (_0, _0, _0)
</code></pre>
<p>First, <code>csa</code> consumes its three inputs <code>a</code>, <code>b</code>, and <code>c</code> as a tuple. Then, it computes the carry save addition on these and puts the result on the output port, <code>signal (f a b c)</code>. Finally, it obtains the next inputs, <code>abc'</code> and continues.</p>
<p><em>What does the type of <code>csa</code> mean?</em> It's worth contemplating the type of <code>csa</code>'s codomain, which is <code>ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()</code>.</p>
<ul>
<li>The input type is <code>(W 8, W 8, W 8)</code>, meaning that every it takes three <code>W 8</code>s each clock cycle;</li>
<li>The output type is <code>(W 8, W 8)</code>, meaning that every it produces two <code>W 8</code>s each clock cycle; and</li>
<li>It does not use any internal storage or registers, hence the <code>Identity</code> monad is used rather than a state monad.</li>
</ul>
<h4 id="running-it-in-ghci"><a class="header" href="#running-it-in-ghci">Running it in GHCi</a></h4>
<p>You can run this using <code>pretty</code> and <code>runP</code> from <code>ReWire.Interactive</code>. First, define some inputs that look familiar:</p>
<pre><code class="language-haskell">inputs :: [(W 8 , W 8 , W 8)]
inputs = (_40 , _25 , _20)
       : (_41 , _25 , _20)
       : (_40 , _25 , _20)  : []
</code></pre>
<pre><code class="language-haskell">λ&gt; :t pretty
pretty :: Pretty a =&gt; a -&gt; IO ()
λ&gt; pretty $ runP start ((_0  , _0  , _0) , (_0  , _0 )) inputs
((0,0,0),(0,0)) :&gt; ((40,25,20),(0,0)) :&gt; ((41,25,20),(48,37)) :&gt; ((40,25,20),(50,36)) :+&gt; Nothing
</code></pre>
<p>(<strong>WARNING:</strong> <code>ReWire.Interactive</code> is currently in <em>super-king-kong-major-hacky</em> form right now.)</p>
<h4 id="compiling-it-with-rwc"><a class="header" href="#compiling-it-with-rwc">Compiling it with RWC</a></h4>
<p>First, here's the entire file as it stands:</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
import Prelude hiding ((^))
import ReWire
import ReWire.Bits

-- | ReWire compiler will complain if this is imported
import ReWire.Interactive

f :: W 8 -&gt; W 8 -&gt; W 8 -&gt; (W 8, W 8)
f a b c = ( ((a .&amp;. b) .|. (a .&amp;. c) .|. (b .&amp;. c) ) &lt;&lt;. lit 1 , (a ^ b) ^ c )

-- Constants for a running example.
_40 , _25 , _20 , _41 , _0 :: W 8
_40 = lit 40
_25 = lit 25
_20 = lit 20
_41 = lit 41
_0  = lit 0

-- |
-- | Example 1. CSA
-- |
-- | The only thing this does is take its inputs i, computes csa on them, and
-- | output the results every clock cycle.

csa :: (W 8, W 8, W 8) -&gt; ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
csa (a, b, c) = do
                   abc' &lt;- signal (f a b c)
                   csa abc'

start :: ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
start = csa (_0, _0, _0)

-- | ReWire compiler will complain if this is here (i.e., comment it before compiling):
inputs :: [(W 8 , W 8 , W 8)]
inputs = (_40 , _25 , _20)
       : (_41 , _25 , _20)
       : (_40 , _25 , _20)  : []
</code></pre>
<p><em>Pro-tip.</em> Because ReWire doesn't know about things likes lists, <code>ReWire.Interactive</code> and the definition of <code>inputs</code> need to be commented out <em>before</em> compiling with <code>rwc</code>. Otherwise, you will receive a non-informative error message like this:</p>
<pre><code class="language-haskell">$ rwc CSA.hs --verilog
Control/Monad/Identity.hs:
Error: File not found in load-path
$ 
</code></pre>
<p>Assuming these are now commented out, you can proceed to compile CSA.hs with:</p>
<pre><code class="language-haskell">$ ls -l CSA.* 
-rw-r--r--  1 william.harrison  staff  1039 Jun 13 09:02 CSA.hs
$ rwc CSA.hs --verilog
$ ls -l CSA.*         
-rw-r--r--  1 william.harrison  staff  1039 Jun 13 09:02 CSA.hs
-rw-r--r--  1 william.harrison  staff  2159 Jun 13 09:04 CSA.v
$ 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="salsa20-case-study"><a class="header" href="#salsa20-case-study">Salsa20 Case Study</a></h1>
<p>This document presents a case study in constructing verified cryptographic hardware in ReWire. In it, I follow the Daniel Bernstein's Salsa20 specification: <a href="https://cr.yp.to/snuffle/spec.pdf">https://cr.yp.to/snuffle/spec.pdf</a>. Throughout this tutorial, I'll refer to this document (i.e., the PDF I just linked to) as either the <em>Salsa20 specification</em> or simply the "<em>spec</em>". Page and section numbers will refer to that document.</p>
<p>The source code for this example can be found here <a href="https://github.com/harrisonwl/rwcrypto">https://github.com/harrisonwl/rwcrypto</a> under <code>src/salsa20</code>. The original version of the ReWire design here was presented at FPT 2015 (linked to below). ReWire's syntax has evolved since then, but the case study here follows that paper.</p>
<p>Generally speaking, when you're going to prove the correctness of a hardware design (or anything else fo that matter really), you need to have:</p>
<ol>
<li>a rigorous standard that constitutes a definition of what <em>to be correct</em> means;</li>
<li>a precise definition of what the implementation and/or design does; and</li>
<li>some mathematical relationship between (1.) and (2.) that you will demonstrate or prove.</li>
</ol>
<p>The standard in (1.) we will call the <em>reference semantics</em> and, for the Salsa20 case study, the
reference semantics is discussed in the first subsection. The reference semantics is effectively
a Haskell/ReWire rendering of the pseudocode functions given in the text of Bernstein's
specification. Our reference semantics is also executable -- e.g., you can load it into GHCi,
type-check it, and run test cases.</p>
<p>The second subsection describes (2.); that is, the actual ReWire code that can be both compiled to Verilog and reasoned about with formal tools. The first implementation we present is designed for simplicity rather than performance. The third subsection describes (3.) at a very high, somewhat informal level. The purpose of this entire tutorial is to focus on ReWire programming.</p>
<h4 id="recent-relevant-publications"><a class="header" href="#recent-relevant-publications">Recent Relevant Publications</a></h4>
<p>A more technical presentation can be found in these recent publications:</p>
<ul>
<li><em>Temporal Staging for Correct-by-Construction Cryptographic Hardware.</em>, Yakir Forman and Bill Harrison. Proceedings of the 2024 Rapid Systems Prototyping (RSP24). <a href="https://harrisonwl.github.io/assets/papers/rsp24.pdf">pdf</a></li>
<li><em>Formalized High Level Synthesis with Applications to Cryptographic Hardware.</em>, Bill Harrison, Ian Blumenfeld, Eric Bond, Chris Hathhorn, Paul Li, May Torrence, and Jared Ziegler. Proceedings of the 2023 NASA Formal Methods Symposium (NFM23). <a href="https://harrisonwl.github.io/assets/papers/nfm23.pdf">pdf</a></li>
<li><em>Provably Correct Development of Reconfigurable Designs via Equational Reasoning.</em>, Ian Graves, Adam Procter, Bill Harrison, and Gerry Allwein. Proceedings of the 2015 International Conference on Field-Programmable Technology (FPT), <a href="https://harrisonwl.github.io/assets/papers/fpt15.pdf">pdf</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-semantics"><a class="header" href="#reference-semantics">Reference Semantics</a></h1>
<p>This section introduces the reference semantics for Salsa20 written in Haskell/ReWire. The development follows Bernstein's specification closely, including a section here corresponding to each one in his specification. The result is an executable, type-checked version of Salsa20 in Haskell/ReWire.</p>
<p>With this Salsa20 reference semantics, we can define a test function (<code>encryptS20 :: String -&gt; String</code> below) that encrypts a message with the same key. Running <code>encryptS20</code> twice on the same plaintext message should, and does, return the original plaintext. For example, consider the following GHCi output where we first print the message and then run the test function on it twice:</p>
<pre><code>λ&gt; putStrLn godzilla_haiku
With artillery
You greet your nuclear child
Am I the monster?
λ&gt; putStrLn (encryptS20 . encryptS20 $ godzilla_haiku)
With artillery
You greet your nuclear child
Am I the monster?
</code></pre>
<h2 id="why-do-you-keep-saying-haskellrewire"><a class="header" href="#why-do-you-keep-saying-haskellrewire">Why do you keep saying <em>Haskell/ReWire</em>?</a></h2>
<p>ReWire is a domain-specific language embedded in Haskell---i.e., every ReWire design is a legal Haskell program but the converse does not hold. When I say <em>Haskell/ReWire</em>, I mean a Haskell program that makes use of ReWire constructs (e.g., bit vectors) but that, for one reason or another, is not legal ReWire. A frequently used Haskell feature that is <em>not</em> inherited by ReWire currently is the type class system. More fundamental is the restrictions on recursion. However, it is often helpful while developing and testing ReWire designs to have access to Haskell's full power.</p>
<h4 id="aside-on-rewires-limits-on-recursion"><a class="header" href="#aside-on-rewires-limits-on-recursion">Aside on ReWire's Limits on Recursion</a></h4>
<p>Functional recursion is limited to functions with codomains typed in <code>ReacT</code>. E.g., recall the carry-save adder example from the previous chapter:</p>
<pre><code class="language-haskell">csa :: (W 8, W 8, W 8) -&gt; ReacT (W 8, W 8, W 8) (W 8, W 8) Identity ()
</code></pre>
<p>Similarly, data recursion (e.g., lists) is not allowed in ReWire because hardware data structures are necessarily finite.</p>
<p>Arbitrary recursion for functions and data requires unbounded storage like heaps and stacks to implement and that is incompatible with hardware's fixed, finite storage footprint.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The reference semantics culminates in the definition of a Salsa20 encryption function of the following type:</p>
<pre><code class="language-haskell">encrypt :: Hex (W 8) -&gt; Hex (W 8) -&gt; Oct (W 8) -&gt; W 64 -&gt; W 8 -&gt; W 8
</code></pre>
<p>What exactly this means will be apparent as you read the reference semantics subsection, but it is simply a Haskell transliteration of the function defined in Section 10 of Bernstein's specification; along the way, I recommend that you keep a copy of his spec handy throughout. At first, you will find that our definitions correspond very closely to his. Towards the end of his spec, I think you will find our reference semantics much easier to understand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="words"><a class="header" href="#words">Words</a></h1>
<p>These definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Basic.hs">Basic.hs</a>.</p>
<p>A <em>word</em> in the context of Bernstein's Salsa20 specification is a bit vector of size 32. Representing bit vectors in ReWire is done via the built-in type constructor for words, <code>W</code>. It is size-indexed so that, for example, 32-bit words are represented by <code>W 32</code>. There are a host of operators defined for words parameterized by size. For example, the type of addition on words has type (checking its type in the GHCi interpreter):</p>
<pre><code class="language-haskell">λ&gt; :type (+)
(+) :: KnownNat n =&gt; W n -&gt; W n -&gt; W n
</code></pre>
<p>This means that, for any natural number <code>n</code>, <code>(+)</code> takes two <code>(W n)</code> and returns a <code>(W n)</code>.</p>
<p>Most bit-vector operations in Verilog or VHDL have a corresponding operation in ReWire.</p>
<h4 id="the-basic-usage-tldr"><a class="header" href="#the-basic-usage-tldr">The Basic Usage TL;DR</a></h4>
<p>The first lines of code for the Salsa20 <code>quarterround</code> function are below and illustrate how to load the built-in bit-vector types and operations in ReWire.</p>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}                    -- 1
module QuarterRound(quarterround) where

import Prelude hiding ((+) , (^))             -- 2
import ReWire                                 -- 3
import ReWire.Bits (lit , rotL , (^) , (+))   -- 4
</code></pre>
<p>To use the built-in bit vector type, one must simply include <code>import ReWire</code> (line <code>3</code>) and also the language directive (<code>1</code>). To use specific operations, one can include them from <code>ReWire.Bits</code> (line <code>4</code>) and some of these operations have the same name as Haskell Prelude operations, so one can exclude these as in line <code>2</code>.</p>
<h4 id="some-additional-type-constructors-for-salsa20"><a class="header" href="#some-additional-type-constructors-for-salsa20">Some additional type constructors for Salsa20</a></h4>
<p>Some additional type constructors used in this specification are included below. We could use Haskell built-in tuple types for these, but it is useful for various technical reasons to define our own larger vector types instead (e.g., it makes pretty-printing values as we wish easier). It's not important to understand the precise details, however.</p>
<pre><code class="language-haskell">data X16 a  = X16 a a a a a a a a a a a a a a a a 

type Quad a = (a , a , a , a)
type Oct a  = (a , a , a , a , a , a , a , a)
type Hex a  = X16 a
    
data X64 a  = X64 a a a a a a a a a a a a a a a a
                  a a a a a a a a a a a a a a a a
                  a a a a a a a a a a a a a a a a
                  a a a a a a a a a a a a a a a a 
</code></pre>
<p>These definitions can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Basic.hs">Basic.hs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-quarter-round-function"><a class="header" href="#the-quarter-round-function">The Quarter Round Function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/QuarterRound.hs">QuarterRound.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_QuarterRound.hs">Test_QuarterRound.hs</a>.</p>
<p>Looking at the pseudocode functions defined in the spec, it is clear that they are, indeed, <em>pure functions</em> in the same sense as Haskell. Hence, it is quite straightforward to transliterate these functions into Haskell/ReWire and this section gives the first such transliteration. An advantage of writing in Haskell rather than pseudocode is that definitions may are type-checked by GHC, providing a quick means of gaining assurance and/or finding stupid bugs.</p>
<h3 id="inputs-and-outputs"><a class="header" href="#inputs-and-outputs">Inputs and Outputs</a></h3>
<p>The <code>quarterround</code> function takes a 4-word sequence as input and produces a 4-word sequence as output. We represent these 4-word sequences as a 4-tuple in Haskell and each word as a <code>W 32</code>. That means that the type of the function will be:</p>
<pre><code class="language-haskell">quarterround :: (W 32 , W 32 , W 32 , W 32) -&gt; (W 32 , W 32 , W 32 , W 32)
</code></pre>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p>The quarterround function from page 2 of
the spec is given as:</p>
<p align="center"><img src="chapters/salsa20/./quarterround.jpg"  style="height:70%; width:70%" ></p>
<p>Rendering this function in Haskell is simple:</p>
<pre><code class="language-haskell">quarterround :: (W 32 , W 32 , W 32 , W 32) -&gt; (W 32 , W 32 , W 32 , W 32)
quarterround (y0 , y1 , y2 , y3) = (z0 , z1 , z2 , z3)
  where
    z0 , z1 , z2 , z3 :: W 32
    z1 = y1 ^ rotL (lit 7) (y0 + y3)
    z2 = y2 ^ rotL (lit 9) (z1 + y0)
    z3 = y3 ^ rotL (lit 13) (z2 + z1)
    z0 = y0 ^ rotL (lit 18) (z3 + z2)
</code></pre>
<p>Note how closely the Haskell text mirrors the definition from the spec text. The XOR operation (\(\oplus\)) is written as <code>^</code>, the left rotate \(\lll\) is written as <code>rotL</code>, etc.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<p>Bernstein provides examples that one can use to sanity-check definitions of <code>quarterround</code>; here they are:</p>
<p align="center"><img src="chapters/salsa20/./QRsanity.jpg"  style="height:70%; width:70%" ></p>
<p>Because we have the function using Haskell/ReWire, we can just evaluate these tests automatically; here are the seven tests from the spec:</p>
<pre><code class="language-haskell">alltests :: [Bool]
alltests = [test1 , test2 , test3 , test4 , test5 , test6 , test7]

test1 , test2 , test3 , test4 , test5 , test6 , test7 :: Bool

test1 = quarterround (lit 0x00000000 , lit 0x00000000 , lit 0x00000000 , lit 0x00000000)
                  == (lit 0x00000000 , lit 0x00000000 , lit 0x00000000 , lit 0x00000000)

test2 = quarterround (lit 0x00000001 , lit 0x00000000 , lit 0x00000000 , lit 0x00000000)
                  == (lit 0x08008145 , lit 0x00000080 , lit 0x00010200 , lit 0x20500000)

test3 = quarterround (lit 0x00000000 , lit 0x00000001 , lit 0x00000000 , lit 0x00000000)
                  == (lit 0x88000100 , lit 0x00000001 , lit 0x00000200 , lit 0x00402000)

test4 = quarterround (lit 0x00000000 , lit 0x00000000 , lit 0x00000001 , lit 0x00000000)
                  == (lit 0x80040000 , lit 0x00000000 , lit 0x00000001 , lit 0x00002000)

test5 = quarterround (lit 0x00000000 , lit 0x00000000 , lit 0x00000000 , lit 0x00000001)
                  == (lit 0x00048044 , lit 0x00000080 , lit 0x00010000 , lit 0x20100001)

test6 = quarterround (lit 0xe7e8c006 , lit 0xc4f9417d , lit 0x6479b4b2 , lit 0x68c67137)
                  == (lit 0xe876d72b , lit 0x9361dfd5 , lit 0xf1460244 , lit 0x948541a3)

test7 = quarterround (lit 0xd3917c5b , lit 0x55f1c407 , lit 0x52a58a7a , lit 0x8f887a3b)
                  == (lit 0x3e2f308c , lit 0xd90a8f36 , lit 0x6ab2a923 , lit 0x2883524c)
</code></pre>
<p>Now, each test is computed:</p>
<pre><code class="language-haskell">λ&gt; alltests
[True,True,True,True,True,True,True]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-rowround-function"><a class="header" href="#the-rowround-function">The <code>rowround</code> Function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/RowRound.hs">RowRound.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_RowRound.hs">Test_RowRound.hs</a>.</p>
<h3 id="inputs-and-outputs-1"><a class="header" href="#inputs-and-outputs-1">Inputs and Outputs</a></h3>
<p>The <code>rowround</code> function takes a 16-word sequence as input and produces a 16-word sequence as output, meaning that the function will have type:</p>
<pre><code class="language-haskell">rowround :: X16 (W 32) -&gt; X16 (W 32)
</code></pre>
<p>where <code>X16</code> is a vector type defined by:</p>
<pre><code class="language-haskell">data X16 a = X16 a a a a a a a a a a a a a a a a
</code></pre>
<p>We could have instead used either Haskell's built-in tuple or vector types defined by ReWire. But the advantage of the <em>roll-your-own</em> vector type <code>X16</code> as we do is that it makes both pattern-matching and displaying values at the GHCi prompt. Exactly how and why is not important for understanding this reference semantics for Salsa20, but a Haskell aficionado will undoubtedly notice this choice.</p>
<h3 id="definition-1"><a class="header" href="#definition-1">Definition</a></h3>
<p align="center"><img src="chapters/salsa20/./rowround.jpg"  style="height:70%; width:70%" ></p>
<h2 id="rendering-in-rewirehaskell"><a class="header" href="#rendering-in-rewirehaskell">Rendering in ReWire/Haskell</a></h2>
<p>Rendered in Haskell, it is:</p>
<pre><code class="language-haskell">rowround :: X16 (W 32) -&gt; X16 (W 32)
rowround (X16 y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15)
   = X16 z0 z1 z2 z3 z4 z5 z6 z7 z8 z9 z10 z11 z12 z13 z14 z15
     where
       ( z0,  z1,  z2,  z3) = quarterround ( y0,  y1,  y2,  y3)
       ( z5,  z6,  z7,  z4) = quarterround ( y5,  y6,  y7,  y4)
       (z10, z11,  z8,  z9) = quarterround (y10, y11,  y8,  y9)
       (z15, z12, z13, z14) = quarterround (y15, y12, y13, y14)
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p align="center"><img src="chapters/salsa20/./RRsanity.jpg"  style="height:70%; width:70%" ></p>
<pre><code class="language-haskell">alltests :: [Bool]
alltests = [test1 , test2]

test1 , test2 :: Bool
test1 = rowround (x16
                    0x00000001 0x00000000 0x00000000 0x00000000
                    0x00000001 0x00000000 0x00000000 0x00000000
                    0x00000001 0x00000000 0x00000000 0x00000000
                    0x00000001 0x00000000 0x00000000 0x00000000)
                   == x16
                        0x08008145 0x00000080 0x00010200 0x20500000
                        0x20100001 0x00048044 0x00000080 0x00010000
                        0x00000001 0x00002000 0x80040000 0x00000000
                        0x00000001 0x00000200 0x00402000 0x88000100

test2 = rowround (x16
                    0x08521bd6 0x1fe88837 0xbb2aa576 0x3aa26365
                    0xc54c6a5b 0x2fc74c2f 0x6dd39cc3 0xda0a64f6
                    0x90a2f23d 0x067f95a6 0x06b35f61 0x41e4732e
                    0xe859c100 0xea4d84b7 0x0f619bff 0xbc6e965a )
                   == x16
                        0xa890d39d 0x65d71596 0xe9487daa 0xc8ca6a86
                        0x949d2192 0x764b7754 0xe408d9b9 0x7a41b4d1
                        0x3402e183 0x3c3af432 0x50669f96 0xd89ef0a8
                        0x0040ede5 0xb545fbce 0xd257ed4f 0x1818882d
</code></pre>
<pre><code class="language-haskell">λ&gt; alltests
[True,True]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-columnround-function"><a class="header" href="#the-columnround-function">The <code>columnround</code> function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/ColumnRound.hs">ColumnRound.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_ColumnRound.hs">Test_ColumnRound.hs</a>.</p>
<h3 id="inputs-and-outputs-2"><a class="header" href="#inputs-and-outputs-2">Inputs and Outputs</a></h3>
<p>If <code>x</code> is a 16-word sequence then <code>columnround(x)</code> is a 16-word sequence. Or, to put it in Haskell terms, the type of <code>columnround</code> is</p>
<pre><code class="language-haskell">columnround :: Hex (W 32) -&gt; Hex (W 32)
</code></pre>
<p>Here, we're assuming:</p>
<pre><code class="language-haskell">type Hex a = X16 a
</code></pre>
<p>and that words are <code>W 32</code>.</p>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<p>The <code>columnround</code> function from page 4 of Bernstein's <em>Salsa20 Specification</em> is given as:</p>
<p align="center"><img src="chapters/salsa20/./columnround.jpg"  style="height:70%; width:70%" ></p>
<h2 id="rendering-in-rewirehaskell-1"><a class="header" href="#rendering-in-rewirehaskell-1">Rendering in ReWire/Haskell</a></h2>
<pre><code class="language-haskell">columnround :: Hex (W 32) -&gt; Hex (W 32)
columnround (X16 x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15)
      = X16 y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15
     where
        y0, y1, y2, y3, y4, y5, y6, y7, y8, y9, y10, y13, y14, y15 :: W 32
        ( y0,  y4,  y8, y12) = quarterround (x0, x4, x8, x12)
        ( y5,  y9, y13,  y1) = quarterround (x5, x9, x13, x1)
        (y10, y14,  y2,  y6) = quarterround (x10, x14, x2, x6)
        (y15,  y3,  y7, y11) = quarterround (x15, x3, x7, x11)
</code></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p align="center"><img src="chapters/salsa20/./CRsanity.jpg"  style="height:65%; width:65%" ></p>
<pre><code class="language-haskell">alltests :: [Bool]
alltests = [test1 , test2]

test1 , test2 :: Bool
test1 = columnround (x16
                        0x00000001 0x00000000 0x00000000 0x00000000
                        0x00000001 0x00000000 0x00000000 0x00000000
                        0x00000001 0x00000000 0x00000000 0x00000000
                        0x00000001 0x00000000 0x00000000 0x00000000)
                        == x16
                              0x10090288 0x00000000 0x00000000 0x00000000
                              0x00000101 0x00000000 0x00000000 0x00000000
                              0x00020401 0x00000000 0x00000000 0x00000000
                              0x40a04001 0x00000000 0x00000000 0x00000000

test2 = columnround (x16
                        0x08521bd6 0x1fe88837 0xbb2aa576 0x3aa26365
                        0xc54c6a5b 0x2fc74c2f 0x6dd39cc3 0xda0a64f6
                        0x90a2f23d 0x067f95a6 0x06b35f61 0x41e4732e
                        0xe859c100 0xea4d84b7 0x0f619bff 0xbc6e965a)
                        == x16
                              0x8c9d190a 0xce8e4c90 0x1ef8e9d3 0x1326a71a
                              0x90a20123 0xead3c4f3 0x63a091a0 0xf0708d69
                              0x789b010c 0xd195a681 0xeb7d5504 0xa774135c
                              0x481c2027 0x53a8e4b5 0x4c1f89c5 0x3f78c9c8
</code></pre>
<p>And, as before, the tests are passed:</p>
<pre><code class="language-haskell">λ&gt; alltests
[True,True]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-doubleround-function"><a class="header" href="#the-doubleround-function">The <code>doubleround</code> function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/DoubleRound.hs">DoubleRound.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_DoubleRound.hs">Test_DoubleRound.hs</a>.</p>
<h3 id="inputs-and-outputs-3"><a class="header" href="#inputs-and-outputs-3">Inputs and Outputs</a></h3>
<p>To quote Bernstein: <em>If <code>x</code> is a 16-word sequence then <code>doubleround(x)</code> is a 16-word sequence.</em> So, its Haskell type is given as:</p>
<pre><code class="language-haskell">doubleround :: Hex (W 32) -&gt; Hex (W 32)
</code></pre>
<h3 id="definition-3"><a class="header" href="#definition-3">Definition</a></h3>
<p>The <code>doubleround</code> function from page 4 of Bernstein's <em>Salsa20 Specification</em> is given as:</p>
<p align="center"><img src="chapters/salsa20/./doubleround.jpg"  style="height:65%; width:65%" ></p>
<h4 id="rendering-in-rewirehaskell-2"><a class="header" href="#rendering-in-rewirehaskell-2">Rendering in ReWire/Haskell</a></h4>
<pre><code class="language-haskell">doubleround :: Hex (W 32) -&gt; Hex (W 32)
doubleround = rowround . columnround
</code></pre>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<p align="center"><img src="chapters/salsa20/./DRsanity.jpg"  style="height:65%; width:65%" ></p>
<pre><code class="language-haskell">alltests :: [Bool]
alltests = [test1 , test2]

test1 , test2 :: Bool
test1 = doubleround i1 == o1
test2 = doubleround i2 == o2

i1 , o1 , i2 , o2 :: Hex (W 32) 
i1 = x16
        0x00000001 0x00000000 0x00000000 0x00000000
        0x00000000 0x00000000 0x00000000 0x00000000
        0x00000000 0x00000000 0x00000000 0x00000000
        0x00000000 0x00000000 0x00000000 0x00000000

o1 = x16
        0x8186a22d 0x0040a284 0x82479210 0x06929051
        0x08000090 0x02402200 0x00004000 0x00800000
        0x00010200 0x20400000 0x08008104 0x00000000
        0x20500000 0xa0000040 0x0008180a 0x612a8020

i2 = x16
        0xde501066 0x6f9eb8f7 0xe4fbbd9b 0x454e3f57
        0xb75540d3 0x43e93a4c 0x3a6f2aa0 0x726d6b36
        0x9243f484 0x9145d1e8 0x4fa9d247 0xdc8dee11
        0x054bf545 0x254dd653 0xd9421b6d 0x67b276c1

o2 = x16
        0xccaaf672 0x23d960f7 0x9153e63a 0xcd9a60d0
        0x50440492 0xf07cad19 0xae344aa0 0xdf4cfdfc
        0xca531c29 0x8e7943db 0xac1680cd 0xd503ca00
        0xa74b2ad6 0xbc331c5c 0x1dda24c7 0xee928277
</code></pre>
<pre><code class="language-haskell">λ&gt; alltests
[True,True]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-littleendian-function"><a class="header" href="#the-littleendian-function">The littleendian function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/LittleEndian.hs">LittleEndian.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_LittleEndian.hs">Test_LittleEndian.hs</a>.</p>
<h3 id="inputs-and-outputs-4"><a class="header" href="#inputs-and-outputs-4">Inputs and Outputs</a></h3>
<p>To quote Bernstein: <em>If <code>b</code> is a 4-byte sequence then <code>littleendian(b)</code> is a word</em>, and, hence, its Haskell type is:</p>
<pre><code class="language-haskell">littleendian :: Quad (W 8) -&gt; W 32     -- i.e., (W 8, W 8, W 8, W 8) -&gt; W 32
</code></pre>
<p>Bernstein also notes that <code>littleendian</code> is invertible, meaning that the following function can be defined:</p>
<pre><code class="language-haskell">inv_littleendian :: W 32 -&gt; Quad (W 8)
</code></pre>
<h3 id="definition-4"><a class="header" href="#definition-4">Definition</a></h3>
<p align="center"><img src="chapters/salsa20/./littleendian.jpg"  style="height:70%; width:70%" ></p>
<h4 id="rendering-in-rewirehaskell-3"><a class="header" href="#rendering-in-rewirehaskell-3">Rendering in ReWire/Haskell</a></h4>
<p>Note that the <code>(++)</code> operator below is vector concatenation (rather than list append from the Haskell prelude). So, in the definition of <code>littleendian</code> below, four <code>(W 8)</code> bit vectors (i.e., <code>b3</code>, <code>b2</code>, <code>b1</code>, and <code>b0</code>) are concatenated to make a single <code>(W 32)</code>.</p>
<pre><code class="language-haskell">revbytes :: Quad (W 8) -&gt; Quad (W 8) 
revbytes (b0,b1,b2,b3) = (b3,b2,b1,b0)

littleendian :: Quad (W 8) -&gt; W 32   
littleendian w8x4 = b3 ++ b2 ++ b1 ++ b0
  where
    b0 , b1 , b2 , b3 :: W 8
    (b3 , b2 , b1 , b0) = revbytes w8x4
</code></pre>
<p>Bernstein also notes that <code>littleendian</code> is invertible:</p>
<pre><code class="language-haskell">inv_littleendian :: W 32 -&gt; Quad (W 8)
inv_littleendian w = revbytes (slice0 w , slice1 w , slice2 w , slice3 w)
</code></pre>
<p>Here, the operation of the slice functions (<code>slice0</code>, etc.) is illustrated by the following test:</p>
<pre><code class="language-haskell">slicetest :: P.Bool
slicetest = (slice0 x , slice1 x , slice2 x , slice3 x) P.== (lit 0xde , lit 0xad , lit 0xbe , lit 0xef)
  where
    x :: W 32
    x = lit 0xdeadbeef
</code></pre>
<p>These functions are defined in <code>LittleEndian.hs</code> and are uninteresting.</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<p align="center"><img src="chapters/salsa20/./LEsanity.jpg"  style="height:50%; width:50%" ></p>
<pre><code class="language-haskell">alltests :: [P.Bool]
alltests = [test1 , test2 , test3] P.++ invertible_tests

test1 , test2 , test3 :: P.Bool 
test1 = littleendian (lit 0,lit 0,lit 0,lit 0)         == lit 0x00000000
test2 = littleendian (lit 86,lit 75,lit 30,lit 9)      == lit 0x091e4b56
test3 = littleendian (lit 255,lit 255,lit 255,lit 250) == lit 0xfaffffff

invertible_tests :: [P.Bool]
invertible_tests = [ invert q0 P.== q0
                   , invert q1 P.== q1
                   , invert q2 P.== q2
                   ]
   where
     invert :: Quad (W 8) -&gt; Quad (W 8)
     invert q = inv_littleendian (littleendian q)
</code></pre>
<pre><code class="language-haskell">λ&gt; slicetest
True
λ&gt; alltests
[True,True,True,True,True,True]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-salsa20-hash-function"><a class="header" href="#the-salsa20-hash-function">The Salsa20 Hash function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/HashSalsa20.hs">HashSalsa20.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_HashSalsa20.hs">Test_HashSalsa20.hs</a>.</p>
<h3 id="inputs-and-outputs-5"><a class="header" href="#inputs-and-outputs-5">Inputs and Outputs</a></h3>
<!-- <p align="center"><img src="chapters/salsa20/./hashfunction.jpg"  style="height:65%; width:65%" ></p> -->
<p>If \(x\) is a 64-byte sequence, then \(\mbox{Salsa20}(x)\) is also a 64-byte sequence. Rendered in Haskell/ReWire types, we define a function with the following type:</p>
<pre><code class="language-haskell">hash_salsa20 :: X64 (W 8) -&gt; X64 (W 8)
</code></pre>
<h3 id="definition-5"><a class="header" href="#definition-5">Definition</a></h3>
<p>Bernstein's definition of the hash function, \(\mbox{Salsa20}\), is more involved than previous functions. It involves three steps.</p>
<ol>
<li>For 64-byte input sequence \(x = (x[0],\ldots,x[63])\),
define 16-byte sequence, \((x_0,\ldots,x_{15})\) as:</li>
</ol>
<p align="center"><img src="chapters/salsa20/./hashfunction1.jpg"  style="height:45%; width:45%" ></p>
<ol start="2">
<li>
<p>Define \((z_0,\ldots,z_{15}) = \mbox{doubleround}^{10}(x_0,\ldots,x_{15})\)</p>
</li>
<li>
<p>Define \(\mbox{Salsa20}(x)\), as the concatenation of the following:</p>
</li>
</ol>
<p align="center"><img src="chapters/salsa20/./hashfunction2.jpg"  style="height:30%; width:30%" ></p>
<h4 id="rendering-in-rewirehaskell-4"><a class="header" href="#rendering-in-rewirehaskell-4">Rendering in ReWire/Haskell</a></h4>
<p>Steps 1.-3. above are rendered in ReWire/Haskell as:</p>
<pre><code class="language-haskell">hash_salsa20 :: X64 (W 8) -&gt; X64 (W 8)
hash_salsa20 (X64   x_0  x_1  x_2  x_3  x_4  x_5  x_6  x_7  x_8  x_9 x_10 x_11 x_12 x_13 x_14 x_15
                   x_16 x_17 x_18 x_19 x_20 x_21 x_22 x_23 x_24 x_25 x_26 x_27 x_28 x_29 x_30 x_31
                   x_32 x_33 x_34 x_35 x_36 x_37 x_38 x_39 x_40 x_41 x_42 x_43 x_44 x_45 x_46 x_47
                   x_48 x_49 x_50 x_51 x_52 x_53 x_54 x_55 x_56 x_57 x_58 x_59 x_60 x_61 x_62 x_63 )
                        = X64
                             a00 a01 a02 a03 a10 a11 a12 a13 a20 a21 a22 a23 a30 a31 a32 a33
                             a40 a41 a42 a43 a50 a51 a52 a53 a60 a61 a62 a63 a70 a71 a72 a73
                             a80 a81 a82 a83 a90 a91 a92 a93 aa0 aa1 aa2 aa3 ab0 ab1 ab2 ab3
                             ac0 ac1 ac2 ac3 ad0 ad1 ad2 ad3 ae0 ae1 ae2 ae3 af0 af1 af2 af3
   where
     x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 , x11 , x12 , x13 , x14 , x15 :: W 32
     x0  = littleendian (  x_0 ,  x_1 ,  x_2 ,  x_3 )
     x1  = littleendian (  x_4 ,  x_5 ,  x_6 ,  x_7 )
     x2  = littleendian (  x_8 ,  x_9 , x_10 , x_11 )
     x3  = littleendian ( x_12 , x_13 , x_14 , x_15 )
     x4  = littleendian ( x_16 , x_17 , x_18 , x_19 )
     x5  = littleendian ( x_20 , x_21 , x_22 , x_23 )
     x6  = littleendian ( x_24 , x_25 , x_26 , x_27 )
     x7  = littleendian ( x_28 , x_29 , x_30 , x_31 )
     x8  = littleendian ( x_32 , x_33 , x_34 , x_35 )
     x9  = littleendian ( x_36 , x_37 , x_38 , x_39 )
     x10 = littleendian ( x_40 , x_41 , x_42 , x_43 )
     x11 = littleendian ( x_44 , x_45 , x_46 , x_47 )
     x12 = littleendian ( x_48 , x_49 , x_50 , x_51 )
     x13 = littleendian ( x_52 , x_53 , x_54 , x_55 )
     x14 = littleendian ( x_56 , x_57 , x_58 , x_59 )
     x15 = littleendian ( x_60 , x_61 , x_62 , x_63 )

     dr10 :: Hex (W 32) -&gt; Hex (W 32)
     dr10 = doubleround . doubleround . doubleround . doubleround . doubleround .
              doubleround . doubleround . doubleround . doubleround . doubleround 

     z0 , z1 , z2 , z3 , z4 , z5 , z6 , z7 , z8 , z9 , z10 , z11 , z12 , z13 , z14 , z15 :: W 32
     (X16 z0 z1 z2 z3 z4 z5 z6 z7 z8 z9 z10 z11 z12 z13 z14 z15)
           = dr10 (X16 x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15)

     (a00 , a01 , a02 , a03) = inv_littleendian (z0 + x0)
     (a10 , a11 , a12 , a13) = inv_littleendian (z1 + x1)
     (a20 , a21 , a22 , a23) = inv_littleendian (z2 + x2)
     (a30 , a31 , a32 , a33) = inv_littleendian (z3 + x3)
     (a40 , a41 , a42 , a43) = inv_littleendian (z4 + x4)
     (a50 , a51 , a52 , a53) = inv_littleendian (z5 + x5)
     (a60 , a61 , a62 , a63) = inv_littleendian (z6 + x6)
     (a70 , a71 , a72 , a73) = inv_littleendian (z7 + x7)

     (a80 , a81 , a82 , a83) = inv_littleendian (z8 + x8)
     (a90 , a91 , a92 , a93) = inv_littleendian (z9 + x9)
     (aa0 , aa1 , aa2 , aa3) = inv_littleendian (z10 + x10)
     (ab0 , ab1 , ab2 , ab3) = inv_littleendian (z11 + x11)
     (ac0 , ac1 , ac2 , ac3) = inv_littleendian (z12 + x12)
     (ad0 , ad1 , ad2 , ad3) = inv_littleendian (z13 + x13)
     (ae0 , ae1 , ae2 , ae3) = inv_littleendian (z14 + x14)
     (af0 , af1 , af2 , af3) = inv_littleendian (z15 + x15)
</code></pre>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<p>Bernstein's specification provides several sanity checks:</p>
<p align="center"><img src="chapters/salsa20/./hashfunctionsanity.jpg"  style="height:65%; width:65%" ></p>
<p>And these sanity checks are rendered in ReWire/Haskell as follows (each returns <code>True</code>):</p>
<pre><code class="language-haskell">test1 :: Bool
test1 = hash_salsa20 i1 == i1

i1 :: X64 (W 8)
i1 = x64 0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0
         0 0 0 0 0 0 0 0 

i2 :: X64 (W 8)
i2 = x64 211 159 13 115 76 55 82 183
           3 117 222 37 191 187 234 136
          49 237 179 48 1 106 178 219
         175 199 166 48 86 16 179 207
          31 240 32 63 15 83 93 161
         116 147 48 113 238 55 204 36
          79 201 235 79 3 81 156 47
         203 26 244 243 88 118 104 54

o2 :: X64 (W 8)
o2 = x64 109 42 178 168 156 240 248 238
         168 196 190 203 26 110 170 154
          29 29 150 26 150 30 235 249
         190 163 251 48 69 144 51 57
         118 40 152 157 180 57 27 94
         107 42 236 35 27 111 114 114
         219 236 232 135 111 155 110 18
          24 232 95 158 179 19 48 202

test2 :: Bool
test2 = hash_salsa20 i2 == o2

i3 , o3 :: X64 (W 8)

i3 = x64 88 118 104 54 79 201 235 79 3 81 156 47 203 26 244 243 191 187 234 136 211 159 13 115 76 55 82 183 3 117 222 37 86 16 179 207 49 237 179 48 1 106 178 219 175 199 166 48 238 55 204 36 31 240 32 63 15 83 93 161 116 147 48 113

o3 = x64 179 19 48 202 219 236 232 135 111 155 110 18 24 232 95 158 26 110 170 154 109 42 178 168 156 240 248 238 168 196 190 203 69 144 51 57 29 29 150 26 150 30 235 249 190 163 251 48 27 111 114 114 118 40 152 157 180 57 27 94 107 42 236 35

test3 :: Bool
test3 = hash_salsa20 i3 == o3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="salsa20-expansion-function"><a class="header" href="#salsa20-expansion-function">Salsa20 Expansion function</a></h2>
<p>The definitions below can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Expansion.hs">Expansion.hs</a> and the testing code can be found in <a href="https://github.com/harrisonwl/rwcrypto/blob/main/src/salsa20/Test_Expansion.hs">Test_Expansion.hs</a>.</p>
<h3 id="inputs-and-outputs-6"><a class="header" href="#inputs-and-outputs-6">Inputs and Outputs</a></h3>
<p>To quote Bernstein, <em>If k is a 32-byte or 16-byte sequence and n is a 16-byte sequence then <code>Salsa20k(n)</code> is a 64-byte sequence.</em> Really, this means that there are two expansion functions, to which we will give the following types:</p>
<pre><code class="language-haskell">salsa20_k0k1 :: (Hex (W 8), Hex (W 8)) -&gt; Hex (W 8) -&gt; X64 (W 8)
salsa20_k :: Hex (W 8) -&gt; Hex (W 8) -&gt; X64 (W 8)
</code></pre>
<p>Just to unpack this, if <em>k</em> is a 32-byte sequence, then <em>k</em> can be split into two 16-byte sequences, <em>k0</em> and <em>k1</em>. So, the first argument's type in <code>salsa20_k0k1</code> is <code>(Hex (W 8), Hex (W 8))</code>. If <em>k</em> is a 16-byte sequence, then that explains the type of the first argument to <code>salsa20_k</code>. I didn't invent this naming scheme, so don't blame me.</p>
<p>Quoting Bernstein again, ** \(\)</p>
<h3 id="defining-salsa20_k0k1"><a class="header" href="#defining-salsa20_k0k1">Defining <code>salsa20_k0k1</code></a></h3>
<p>Bernstein first defines several 4-tuples of constants, each of which is implicitly assumed to be a single byte:
\[
\begin{array}{lcl}
\sigma_0 &amp;=&amp; (101,120,112,97)
\newline
\sigma_1 &amp;=&amp; (110,100,32,51)
\newline
\sigma_2 &amp;=&amp; (50,45,98,121)
\newline
\sigma_3 &amp;=&amp; (116,101,32,107)
\end{array}
\]
Note that each \(\sigma_i\) would have type <code>(W 8 , W 8 , W8 , W 8)</code> if defined in Haskell/ReWire and, consequently, there are sixteen bytes total contained in them.</p>
<p>The 32-byte expansion function is then defined as:
\[
Salsa20_{k0k1}(n) = Salsa20(\sigma_0,k_0,\sigma_1,n,\sigma_2,k_1,\sigma_3)
\]
where \(Salsa20\) is the Salsa20 hash function from the previous subsection. The argument to \(Salsa20\) (i.e., the 7-tuple \((\sigma_0,k_0,\sigma_1,n,\sigma_2,k_1,\sigma_3)\)) contains 64 bytes in total. However, the argument is intended to be a 64-byte sequence or, in terms of Haskell/ReWire, it has type <code>X64 (W 8)</code>. Below, I define a function called <code>expandk0k1</code> to construct this argument.</p>
<h3 id="rendering-in-haskellrewire"><a class="header" href="#rendering-in-haskellrewire">Rendering in Haskell/ReWire</a></h3>
<p>It is probably easier to understand this definition by looking directly at its expression in Haskell/ReWire:</p>
<pre><code class="language-haskell">salsa20_k0k1 :: (Hex (W 8), Hex (W 8)) -&gt; Hex (W 8) -&gt; X64 (W 8)
salsa20_k0k1 (k0,k1) n = hash_salsa20 (expandk0k1 (k0 , k1 , n))

expandk0k1 :: (Hex (W 8), Hex (W 8), Hex (W 8)) -&gt; X64 (W 8)
expandk0k1 
       ( (X16 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16) -- k0
       , (X16 z1 z2 z3 z4 z5 z6 z7 z8 z9 z10 z11 z12 z13 z14 z15 z16) -- k1
       , (X16 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16) -- n
       ) = let
              sigma0 , sigma1 , sigma2 , sigma3 :: Quad (W 8)
              sigma0@(x1,x2,x3,x4) = (lit 101, lit 120, lit 112,  lit 97)
              sigma1@(w1,w2,w3,w4) = (lit 110, lit 100,  lit 32,  lit 51)
              sigma2@(v1,v2,v3,v4) = ( lit 50,  lit 45,  lit 98, lit 121)
              sigma3@(t1,t2,t3,t4) = (lit 116, lit 101,  lit 32, lit 107)
           in
             X64
                 x1 x2 x3 x4
                 --
                 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12 y13 y14 y15 y16
                 --
                 w1 w2 w3 w4
                 --
                 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15 u16
                 --
                 v1 v2 v3 v4
                 --
                 z1 z2 z3 z4 z5 z6 z7 z8 z9 z10 z11 z12 z13 z14 z15 z16
                 --
                 t1 t2 t3 t4
                 --
</code></pre>
<h3 id="defining-the-16-byte-expansion-function"><a class="header" href="#defining-the-16-byte-expansion-function">Defining the 16-byte Expansion Function</a></h3>
<p>The 16-byte expansion function is  defined as:
\[
Salsa20_{k}(n) = Salsa20(\tau_0,k,\tau_1,n,\tau_2,k,\tau_3)
\]
where the \(\tau_i\) are defined as:
\[
\begin{array}{lcl}
\tau_0 &amp;=&amp; (101,120,112,97)
\newline
\tau_1 &amp;=&amp; (110,100,32,49)
\newline
\tau_2 &amp;=&amp; (54,45,98,121)
\newline
\tau_3 &amp;=&amp; (116,101,32,107)
\end{array}
\]
Note that the argument to \(Salsa20\) has 64 bytes in total and we defined a function <code>expandk</code> to construct this argument.</p>
<h3 id="rendering-in-haskellrewire-1"><a class="header" href="#rendering-in-haskellrewire-1">Rendering in Haskell/ReWire</a></h3>
<p>The definition of the 16-byte expansion function <code>salsa20_k</code> is very similar to the 32-byte function defined above:</p>
<pre><code class="language-haskell">salsa20_k :: Hex (W 8) -&gt; Hex (W 8) -&gt; X64 (W 8)
salsa20_k k n = hash_salsa20 (expandk k n)

expandk :: Hex (W 8) -&gt; Hex (W 8) -&gt; X64 (W 8)
expandk k@(X16 k1 k2 k3 k4 k5 k6 k7 k8 k9 k10 k11 k12 k13 k14 k15 k16)
        n@(X16 n1 n2 n3 n4 n5 n6 n7 n8 n9 n10 n11 n12 n13 n14 n15 n16)
       = let
             tau0 , tau1 , tau2 , tau3 :: Quad (W 8)
             tau0@(x1 , x2 , x3 , x4) = (lit 101,lit 120,lit 112,lit 97)
             tau1@(y1 , y2 , y3 , y4) = (lit 110,lit 100,lit 32,lit 49)
             tau2@(u1 , u2 , u3 , u4) = (lit 54,lit 45,lit 98,lit 121)
             tau3@(v1 , v2 , v3 , v4) = (lit 116,lit 101,lit 32,lit 107)
         in
           X64
               --- tau0
               x1 x2 x3 x4 
               --- k
               k1 k2 k3 k4 k5 k6 k7 k8 k9 k10 k11 k12 k13 k14 k15 k16
               --- tau1
               y1 y2 y3 y4
               --- n
               n1 n2 n3 n4 n5 n6 n7 n8 n9 n10 n11 n12 n13 n14 n15 n16
               --- tau2
               u1 u2 u3 u4
               --- k
               k1 k2 k3 k4 k5 k6 k7 k8 k9 k10 k11 k12 k13 k14 k15 k16
               --- tau3
               v1 v2 v3 v4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="salsa20-encryption-function"><a class="header" href="#salsa20-encryption-function">Salsa20 Encryption function</a></h2>
<h3 id="remarks-on-section-10--a-quick-demo"><a class="header" href="#remarks-on-section-10--a-quick-demo">Remarks on Section 10 &amp; A Quick Demo</a></h3>
<h3 id="inputs-and-outputs-7"><a class="header" href="#inputs-and-outputs-7">Inputs and Outputs</a></h3>
<h3 id="definition-6"><a class="header" href="#definition-6">Definition</a></h3>
<pre><code class="language-haskell">encrypt :: Hex (W 8) -&gt; Hex (W 8) -&gt; Oct (W 8) -&gt; W 64 -&gt; W 8 -&gt;  W 8
encrypt k0 k1 v i mi = mi ^ ((salsa20_k0k1 (k0 , k1) (splice v (factor64 i))) `pi64` (mod64 i))
</code></pre>
<pre><code class="language-haskell">-- |
-- | This is factor function tweeked so that it takes (W 64) as input instead of Integer. 
-- |
factor64 :: W 64 -&gt; (W 8 , W 8 , W 8 , W 8 , W 8 , W 8 , W 8 , W 8 )
mod64    :: W 64 -&gt; W 6
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
